= Integration Scenarios with Debezium and Camel
jpechane
:awestruct-tags: [ camel, integration, quarkus ]
:awestruct-layout: blog-post

One of the typical Debezium uses cases is to use change data capture to integrate a legacy system with other systems in the organization.
There are multiple ways how to achieve this goal

* Write data to Kafka using Debezium and follow with a combination of Kafka Streams pipelines and Kafka Connect connectors to deliver the changes to other systems
* Use Debezium Embedded engine in a Java standalone application and write the integration code using plain Java
* Use existing integration framework or service bus to express the pipeline logic

This article is focusing on the third option - a dedicated integration framework.


== Apache Camel

https://camel.apache.org/[Camel] is an open-source integration framework that enables the developer to read and write data from and to disparate systems and services.
It provides a large amount of https://camel.apache.org/components/latest/[components] that either provide interfaces to 3rd party systems or provides an implementation of https://en.wikipedia.org/wiki/Enterprise_Integration_Patterns[enterprise integration patterns].

This combination allows the developer to easily connect to target systems and express integration pipelines using declarative DSL.


=== Camel and Debezium

https://camel.apache.org/blog/Camel3-Whatsnew/[Camel 3] has been released by the end of the year 2019 and in addition to the major re-architecture new Debezium components has been added to the codebase.

* https://camel.apache.org/components/latest/debezium-mysql-component.html[Debezium MySQL Connector Component]
* https://camel.apache.org/components/latest/debezium-postgres-component.html[Debezium PostgreSQL Connector Component]
* https://camel.apache.org/components/latest/debezium-sqlserver-component.html[Debezium SQL Server Connector Component]
* https://camel.apache.org/components/latest/debezium-mongodb-component.html[Debezium MongoDB Connector Component]

As you can see every Debezium connector is represented by its dedicated component.
The advantage of this solution is the complete isolation of dependencies and the type-safe configuration of connector instances.

Internally the component exposes a Debezium endpoint with Camel consumer that encapsulates an instance of https://debezium.io/documentation/reference/1.1/operations/embedded.html[Debezium embedded engine].


== Example

We have prepared https://github.com/debezium/debezium-examples/tree/master/camel-component[an example] of how to deploy an integration pipeline using Debezium component.

The source of change data is a simple Question & Answer (QnA) application.
The changes generated by the application are passed to the Camel pipeline that sends emails via an SMTP server and posts a tweet on a provided Twitter account.


=== Topology

There are multiple components in the solution topology.

.The Deployment topology
[#img-topology]
[caption="Figure 1: "]
image::camel-component-topology.svg[Deployment topology]

&nbsp; +
The QaN application runs as a Quarkus application and exposes a REST API to create questions and answers.
The application stores the data in the PostgreSQL database.
The Camel route runs as a plain Java application that uses https://infinispan.org/[Infinispan] to store its state and sends messages to https://github.com/mailhog/MailHog[MailHog] SMTP server running in a container and into an associated Twitter account.


==== Question & Answer application

The source application is a simple application developed using https://quarkus.io/[Quarkus framework].
It provides two entities `Question` and `Answer` with `1:n` relation stored in the PostgreSQL database.

.The QnA backend service ERD
[#img-qna-erd]
[caption="Figure 2: "]
image::camel-component-erd.svg[QnA backend service ERD]

&nbsp; +

The entities are created using REST API and the association is automatically established between them.


==== Camel pipeline

Camel pipeline is an expression of the following business rules

* For every question created or updated send an email to the question creator
* For every answer created or updated send an email to both question and answer creator
* When a question achieves three answers post a tweet on a dedicated Twitter account about it

The business requirements are transformed into a pipeline described by the EIP chart

.The Camel pipeline
[#img-pipeline]
[caption="Figure 3: "]
image::camel-component-pipeline.svg[Camel pipeline]

&nbsp; +


== Demo

To run the demo successfully you need to have a developer Twitter account with appropriate API keys and secrets.

Got to the application directory and build all components

[source,shell]
----
$ mvn clean install
----

Start PostgreSQL database and MailHog SMTP server

[source,shell]
----
$ mvn -N docker:start
----

In another terminal start the Q&A application backend service

[source,shell]
----
$ java -jar qa-app/target/component-qa-app-1.0.0-SNAPSHOT-runner.jar
----

In yet another terminal start the Camel pipeline (provide your own Twitter API credentials)

[source,shell]
----
$ mvn exec:java -Dtwitter.consumerKey=<...> -Dtwitter.consumerSecret=<...> -Dtwitter.accessToken=<...> -Dtwitter.accessTokenSecret=<...> -pl qa-camel
----

Create a question and three answers to it
[source,shell]
----
$ curl -v -X POST -H 'Content-Type: application/json' http://0.0.0.0:8080/question/ -d @src/test/resources/messages/create-question.json
$ curl -v -X POST -H 'Content-Type: application/json' http://0.0.0.0:8080/question/1/answer -d @src/test/resources/messages/create-answer1.json
$ curl -v -X POST -H 'Content-Type: application/json' http://0.0.0.0:8080/question/1/answer -d @src/test/resources/messages/create-answer2.json
$ curl -v -X POST -H 'Content-Type: application/json' http://0.0.0.0:8080/question/1/answer -d @src/test/resources/messages/create-answer3.json
----

The Twitter account should contain a new tweet with a text like `Question 'How many legs does a dog have?' has many answers (generated at 2020-02-17T08:02:33.744Z)`.

The http://localhost:8025/[MailHog server UI] should display messages like

.The MailHog messages
[#img-mailhog]
[caption="Figure 4: "]
image::camel-component-mailhog.png[MailHog messages]

&nbsp; +


== Code walkthrough

To use Debezium Camel component we need to add at least following dependencies into a `pom.xml` file

[source,xml]
----
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.apache.camel</groupId>
                <artifactId>camel-bom</artifactId>
                <version>${version.camel}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Use required Debezium version -->
            <dependency>
                <groupId>io.debezium</groupId>
                <artifactId>debezium-connector-postgres</artifactId>
                <version>${version.debezium}</version>
            </dependency>
            <dependency>
                <groupId>io.debezium</groupId>
                <artifactId>debezium-embedded</artifactId>
                <version>${version.debezium}</version>
            </dependency>
            <dependency>
                <groupId>io.debezium</groupId>
                <artifactId>debezium-core</artifactId>
                <version>${version.debezium}</version>
            </dependency>

        </dependencies>
    </dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.camel</groupId>
            <artifactId>camel-debezium-postgres</artifactId>
        </dependency>
    </dependencies>
----

The pipeline logic itself is defined in https://github.com/debezium/debezium-examples/blob/master/camel-component/qa-camel/src/main/java/io/debezium/examples/camel/pipeline/QaDatabaseUserNotifier.java[QaDatabaseUserNotifier] class.

The main route looks like

[source,java]
----
    from("debezium-postgres:localhost?"
            + "databaseHostname={{database.hostname}}"
            + "&databasePort={{database.port}}"
            + "&databaseUser={{database.user}}"
            + "&databasePassword={{database.password}}"
            + "&databaseDbname=postgres"
            + "&databaseServerName=qa"
            + "&schemaWhitelist={{database.schema}}"
            + "&tableWhitelist={{database.schema}}.question,{{database.schema}}.answer"
            + "&offsetStorage=org.apache.kafka.connect.storage.MemoryOffsetBackingStore")
            .routeId(QaDatabaseUserNotifier.class.getName() + ".DatabaseReader")         // (1)
            .log(LoggingLevel.DEBUG, "Incoming message ${body} with headers ${headers}")
            .choice()                                                                    // (2)
                .when(isQuestionEvent)
                    .filter(isCreateOrUpdateEvent)                                       // (3)
                        .convertBodyTo(Question.class)                                   // (4)
                        .log(LoggingLevel.TRACE, "Converted to logical class ${body}")
                        .bean(store, "readFromStoreAndUpdateIfNeeded")                   // (5)
                        .to(ROUTE_MAIL_QUESTION_CREATE)                                  // (6)
                    .endChoice()
                .when(isAnswerEvent)
                    .filter(isCreateOrUpdateEvent)
                        .convertBodyTo(Answer.class)
                        .log(LoggingLevel.TRACE, "Converted to logical class ${body}")
                        .bean(store, "readFromStoreAndAddAnswer")
                        .to(ROUTE_MAIL_ANSWER_CHANGE)
                        .filter(hasManyAnswers)                                          // (7)
                            .setBody().simple("Question '${exchangeProperty[aggregate].text}' has many answers (generated at " + Instant.now() + ")")
                            .to(TWITTER_SERVER)
                        .end()
                    .endChoice()
                .otherwise()
                    .log(LoggingLevel.WARN, "Unknown type ${headers[" + DebeziumConstants.HEADER_IDENTIFIER + "]}")
            .endParent();



    @Converter
    public static Question questionFromStruct(Struct struct) {                           // (4)
        return new Question(struct.getInt64("id"), struct.getString("text"), struct.getString("email"));
    }

    from(ROUTE_MAIL_QUESTION_CREATE)                                                     // (6)
        .routeId(QaDatabaseUserNotifier.class.getName() + ".QuestionNotifier")
        .setHeader("To").simple("${body.email}")
        .setHeader("Subject").simple("Question created/edited")
        .setBody().simple("Question '${body.text}' was created or edited")
        .to(SMTP_SERVER);

----

1. `from` is the Debezium source endpoint. The URI parts map directly to connector configuration options.
2. The pipeline logic is split depending on the change event type.
The recognition is based on `CamelDebeziumIdentifier` header which contains the identifier (`<server_name>.<schema_name>.<table_name>`) of the source table.
3. The pipeline is now able to process only updates and deletes.
The recognition is based on `CamelDebeziumOperation` header that contains `op` field of the message `Envelope`.
4. The Kafka Connect's `Struct` type is converted into a logical type used in the pipeline.
The conversion is performed by a custom Camel converter.
It is possible to use out-of-the-box `DebeziumTypeConverter` that converts `Struct` into a `Map` but this tightly couples pipeline logic into the table structure.
5. A supplementary route is invoked that communicates with a https://github.com/debezium/debezium-examples/blob/master/camel-component/qa-camel/src/main/java/io/debezium/examples/camel/pipeline/AggregateStore.java[message store] based on an Infinispan cache to build a message aggregate.
The message store checks if it has the question already stored.
If not a new aggregate is created and stored otherwise the stored aggregate is updated with new data.
6. A supplementary route is invoked that formats a mail message and delivers it to the question creator via the SMTP endpoint.
7. The route part related to the answer message type is very similar (answers are added to question aggregate).
The main difference is the posting of a Twitter message when the aggregate contains three answers.


== Conclusion

Apache Camel integration is an interesting option for system integration scenarios.
When Kafka broker is not necessary to be deployed in the solution it is very easy to deploy a standalone Camel route with Debezium component that enables capturing of change data and execute very complex routing and transformation operations on it and provides the developer with a full arsenal of enterprise integration patterns and more than hundred connectors for different systems that could be included in a complex service orchestration.

== About Debezium

Debezium is an open-source distributed platform that turns your existing databases into event streams,
so applications can see and respond almost instantly to each committed row-level change in the databases.
Debezium is built on top of http://kafka.apache.org/[Kafka] and provides http://kafka.apache.org/documentation.html#connect[Kafka Connect] compatible connectors that monitor specific database management systems.
Debezium records the history of data changes in Kafka logs, so your application can be stopped and restarted at any time and can easily consume all of the events it missed while it was not running,
ensuring that all events are processed correctly and completely.
Debezium is link:/license/[open source] under the http://www.apache.org/licenses/LICENSE-2.0.html[Apache License, Version 2.0].

== Get involved

We hope you find Debezium interesting and useful and want to give it a try.
Follow us on Twitter https://twitter.com/debezium[@debezium], https://gitter.im/debezium/user[chat with us on Gitter],
or join our https://groups.google.com/forum/#!forum/debezium[mailing list] to talk with the community.
All of the code is open-source https://github.com/debezium/[on GitHub],
so build the code locally and help us improve our existing connectors and add even more connectors.
If you find problems or have an idea on how we can improve Debezium, please let us know or https://issues.redhat.com/projects/DBZ/issues/[log an issue].

