= Debezium meets Quarkus
jpechane
:awestruct-tags: [ quarkus, examples, microservices, apache-kafka ]
:awestruct-layout: blog-post

[role="teaser"]
--
A new community project for developing cloud-native applications https://quarkus.io/[Quarkus] has been launched.
We are going to demonstrate how a Quarkus-based application could be used to consume event messages created with link:2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern[outbox pattern].
--

== About Quarkus
https://quarkus.io/[Quarkus] is a Java stack designed for development of cloud-native applications based on Java platform.
It provides a subset of best-of-breed technologies and libraries that are neatly integrated together.
It supports a development of both imperative and reactive applications with support for mixing of both approaches together.
It is designed for significantly reduced memory consumption and improved startup time.

Last but not least it supports both OpenJDK HotSpot and GraalVM virtual machines.
With GraalVM it is possible to compile the application into a native binary and thus reduce the resource consumption and startup time even more.

== Service implementation

We have extended the https://github.com/debezium/debezium-examples/tree/master/outbox[example application] introduced in the link:2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern[recent blog post] with a new service named `shipment-service-quarkus`.
It provides the same functionality as the `shipment-service` does with few implementation differences

 * Quarkus right now supports only MariaDB database, not MySQL, so we have included an instance on MariaDB database to which the service is writing
 * JSON-P API is not supported yet, the JSON parser of choice is Jackson. The code has been modified to use Jackson API instead of JSON-P API.
 * Quarkus supports https://github.com/eclipse/microprofile-reactive-messaging[Reactive Messaging for MicroProfile] via http://smallrye.io/[SmallRye] implementation. We no longer need to use Kafka client as the message listener is implemented declaratively.

== Build process

The build process is almost the same as was original.
There are two changes though

 * the `native` profile is enabled in Maven build. This implies that the service will use GraalVM and be compiled into a native binary image.
 * `native-image.docker-build` system property is enabled. This means that the native image build is done inside a Docker container and that the developer's machine does not need to have GraalVM installed locally.

== Configuration

The application contains two configuration files

 * `application.properties` in our case contains the only definition of a datasource to which the service writes its data
 * `META-INF/microprofile-config.properties` in our case contains a definition of Kafka source from which we consume the outbox events

== Execution

The Docker Compose config file has been enriched with two services - MariaDB and the new shipment service.
So when `docker-compose up` is executed two shipment services are started side-by-side - Thorntail based and Quarkus based.
When an event is created it is processed by both services as they are using distinct consumer groups.

== Performance numbers

The numbers are definitely not scientific but can be seen as an order of magnitude difference between native Quarkus-based application and OpenJDK Thorntail-based.

[cols="30%a,35%a,35%a",options="header,footer",role="table table-bordered table-striped"]
|=======================
|
|Quarkus service
|Thorntail service

|memory [MB]
|33.8
|1257

|start time [ms]
|260
|5746

|application package size [MB]
|54
|131

|=======================

== Summary

We have successfully demonstrated in this blog post that it is possible to consume Debezium-generated events from a Java application written with Quarkus Java stack.
We have also shown that it is possible to provide such application as a binary image and provided back-of-the-envelope performance numbers demonstrating significant savings in resources.

== About Debezium

Debezium is an open source distributed platform that turns your existing databases into event streams,
so applications can see and respond almost instantly to each committed row-level change in the databases.
Debezium is built on top of http://kafka.apache.org/[Kafka] and provides http://kafka.apache.org/documentation.html#connect[Kafka Connect] compatible connectors that monitor specific database management systems.
Debezium records the history of data changes in Kafka logs, so your application can be stopped and restarted at any time and can easily consume all of the events it missed while it was not running,
ensuring that all events are processed correctly and completely.
Debezium is link:/license/[open source] under the http://www.apache.org/licenses/LICENSE-2.0.html[Apache License, Version 2.0].

== Get involved

We hope you find Debezium interesting and useful, and want to give it a try.
Follow us on Twitter https://twitter.com/debezium[@debezium], https://gitter.im/debezium/user[chat with us on Gitter],
or join our https://groups.google.com/forum/#!forum/debezium[mailing list] to talk with the community.
All of the code is open source https://github.com/debezium/[on GitHub],
so build the code locally and help us improve ours existing connectors and add even more connectors.
If you find problems or have ideas how we can improve Debezium, please let us know or https://issues.jboss.org/projects/DBZ/issues/[log an issue].
