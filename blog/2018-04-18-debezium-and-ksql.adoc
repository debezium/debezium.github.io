= Querying Debezium created events with KSQL
jpechane
:awestruct-tags: [ mysql, ksql, example ]
:awestruct-layout: blog-post

Last year we have seen an inception of a new open-source project https://github.com/confluentinc/ksql[KSQL].
KSQL is a streaming SQL engine for https://kafka.apache.org/[Apache Kafka] that is build on top of https://kafka.apache.org/documentation/streams/[Kafka Streams].
We are going to try the KSQL querying with events generated by Debezium from a MySQL database.

As a source of data we will use the database and setup from our link:/docs/tutorial[tutorial].
The result of this exercise should be similar to the recent link:/blog/2018/03/08/creating-ddd-aggregates-with-debezium-and-kafka-streams/[post] about aggregation of events into link:https://martinfowler.com/bliki/DDD_Aggregate.html[domain driven aggregates].

== Entity diagram
First let's look at entities in the database and relations between them.

.A entity diagram
[#img-general]
[caption="Figure 1: "]
image::tutorial-erd.svg[Entity diagram]

&nbsp; +

The picture above shows full ER diagram for inventory database in the example database.
We are going to focus on two entities

 - `customers` - the list of customers in the system
 - `orders` - the list of orders in the system
 
There is a `1:n` relation between `customers` and `orders` and `purchaser` column in table `orders` is a foreign key to the table `customers`.

== Configuration
We are going to use a https://github.com/debezium/debezium-examples/blob/master/tutorial/docker-compose-mysql.yaml[Docker Compose file] for the deployment of the environment.
The deployment consists of the following Docker images:

* https://hub.docker.com/r/debezium/zookeeper/[Apache ZooKeeper]
* https://hub.docker.com/r/debezium/kafka/[Apache Kafka]
* Kafka Connect / Debezium https://hub.docker.com/r/debezium/connect/[image]
* Pre-populated MySQL as used in our link:/docs/tutorial[tutorial]

We also need a KSQL client.
To make things simple we are going to use pre-built https://hub.docker.com/r/confluentinc/ksql-cli/[Docker image] but you can download and directly use the client from KSQL https://github.com/confluentinc/ksql/releases[download] page.

== Example
First we need to start the Debezium and Kafka infrastructure
[source,bash,indent=0]
----
export DEBEZIUM_VERSION=0.7
docker-compose -f docker-compose-mysql.yaml up
----

Next we must register Debezium MySQL connector to listen on the database
[source,bash,indent=0]
----
curl -i -X POST -H "Accept:application/json" -H  "Content-Type:application/json" http://localhost:8083/connectors/ -d @- <<-EOF
{
    "name": "inventory-connector",
    "config": {
        "connector.class": "io.debezium.connector.mysql.MySqlConnector",
        "tasks.max": "1",
        "database.hostname": "mysql",
        "database.port": "3306",
        "database.user": "debezium",
        "database.password": "dbz",
        "database.server.id": "184055",
        "database.server.name": "dbserver",
        "database.whitelist": "inventory",
        "database.history.kafka.bootstrap.servers": "kafka:9092",
        "database.history.kafka.topic": "schema-changes.inventory",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.UnwrapFromEnvelope",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "key.converter.schemas.enable": "false",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false"
    }
}
EOF
----

Now we should have all components up and running and initial database events are already streamed into Kafka topics.
There are mutliple properties that are especially important for our use case

 - http://debezium.io/docs/configuration/event-flattening/[UnwrapFromEnvelope SMT] is used.
 This allows us to directly map fields from `after` part of record into KSQL statements.
 Without it we would need to use `EXTRACTJSONFIELD` for each field to be extracted from `after` part of message.
 - Schemas are disabled for JSON converter.
 The reason is the same as above.
 With schemas enabled for JSON the record is encapsulated in a JSON that contains fields `schema` witch schemas and `payload` with the message itself.
 We would again need to use `EXTRACTJSONFIELD` to get to the fields.
 There is no such issue with Avro converter so this option does not need to be set when Avro is used.

Next we are going to start KSQL command shell.
We will run a local engine in the CLI.
Also please note `--net` parameter. This guarantees that KSQL container runs in the same network as Debezium containers and allows proper DNS resolution.

[source,bash,indent=0]
----
docker run -it --net tutorial_default confluentinc/ksql-cli ksql-cli local --bootstrap-server kafka:9092
----

First we will list all Kafka topics that exists in the broker
[source,bash,indent=0]
----
ksql> LIST TOPICS;

 Kafka Topic                         | Registered | Partitions | Partition Replicas 
------------------------------------------------------------------------------------
 connect-status                      | false      | 5          | 1                  
 dbserver                            | false      | 1          | 1                  
 dbserver.inventory.addresses        | false      | 1          | 1                  
 dbserver.inventory.customers        | false      | 1          | 1                  
 dbserver.inventory.orders           | false      | 1          | 1                  
 dbserver.inventory.products         | false      | 1          | 1                  
 dbserver.inventory.products_on_hand | false      | 1          | 1                  
 ksql__commands                      | true       | 1          | 1                  
 my_connect_configs                  | false      | 1          | 1                  
 my_connect_offsets                  | false      | 25         | 1                  
 schema-changes.inventory            | false      | 1          | 1                  
----

The topics we are interested in are `dbserver.inventory.orders` and `dbserver.inventory.customers`.

KSQL processing by default starts with `latest` offsets.
We want to process the events already in topics so we switch processing from `earliest` offsets.

[source,bash,indent=0]
----
ksql> SET 'auto.offset.reset' = 'earliest';
Successfully changed local property 'auto.offset.reset' from 'null' to 'earliest'
----

First we create streams from topics containing Debezium events.
Stream in KSQL and kafka Streams terminology is an unbounded incoming data set with no state.
[source,bash,indent=0]
----
ksql> CREATE STREAM orders_from_debezium (order_number integer, order_date string, purchaser integer, quantity integer, product_id integer) WITH (KAFKA_TOPIC='dbserver.inventory.orders',VALUE_FORMAT='json');

 Message        
----------------
 Stream created 
ksql> 
ksql> CREATE STREAM customers_from_debezium (id integer, first_name string, last_name string, email string) WITH (KAFKA_TOPIC='dbserver.inventory.customers',VALUE_FORMAT='json');

 Message        
----------------
 Stream created 
----

=== Partitioning
Our deployment uses only one partition per topic.
In a production system there will be multiple partitions per topic and we need to ensure that all events belonging to our aggregated obejct ends up in the same partition.
The natural partioning in our case is per customer id.
We are going to repartition `orders_from_debezium` stream accroding to `purchaser` field that contains the customer id.
The repartitioned data are written into a new topic `ORDERS_REPART`.

[source,bash,indent=0]
----
ksql> CREATE STREAM orders WITH (KAFKA_TOPIC='ORDERS_REPART',VALUE_FORMAT='json',PARTITIONS=1) as SELECT * FROM orders_from_debezium PARTITION BY PURCHASER;

 Message                    
----------------------------
 Stream created and running 
ksql> LIST TOPICS;

 Kafka Topic                         | Registered | Partitions | Partition Replicas 
------------------------------------------------------------------------------------
...
 ORDERS_REPART                       | true       | 1          | 1                  
...
----

We are going to execute the same operation for customers too.
It is necessary for two reasons

 - The current key is a struct that contains a field named `id` with the customer id.
 This is different from repartitioned order topic as it contains only the `id` value as the key so the partitions would not match.
 - When we will try to create a JOIN later there is a limitation that requires key to have the same value as a key field in the table.
 The table field contains a plain value but key contains a struct so they would not match.
 See a KSQL https://github.com/confluentinc/ksql/issues/749[issue] for more details.

[source,bash,indent=0]
----
ksql> CREATE STREAM customers_stream WITH (KAFKA_TOPIC='CUSTOMERS_REPART',VALUE_FORMAT='json',PARTITIONS=1) as SELECT * FROM customers_from_debezium PARTITION BY ID;

 Message                    
----------------------------
 Stream created and running 
ksql> LIST TOPICS;

 Kafka Topic                         | Registered | Partitions | Partition Replicas 
------------------------------------------------------------------------------------
...
 CUSTOMERS_REPART                    | true       | 1          | 1                  
...
----

To verify that records have a new key and are thus repartioned we can issue few statements to compare the results
[source,bash,indent=0]
----
ksql> SELECT * FROM orders_from_debezium LIMIT 1;
1524034842810 | {"order_number":10001} | 10001 | 16816 | 1001 | 1 | 102
LIMIT reached for the partition.
Query terminated
ksql> SELECT * FROM orders LIMIT 1;
1524034842810 | 1001 | 10001 | 16816 | 1001 | 1 | 102
LIMIT reached for the partition.
Query terminated
----

The second column contains `ROWKEY` which is the key of the message.

==== Customer/order join
So far we were only declaring streams as an unbounded staless data set.
In our use case the `order` is really an event that comes and goes.
But `customer` is an entity that can be updated and generally is a part of a state fo the system.
Such quality is represented in KSQL or Kafka Streams as table.
We are goind to create a table of customers from the topic containing repartitioned customers.

[source,bash,indent=0]
----
ksql> CREATE TABLE customers (id integer, first_name string, last_name string, email string) WITH (KAFKA_TOPIC='CUSTOMERS_REPART',VALUE_FORMAT='json',KEY='id');

 Message       
---------------
 Table created 
----

Now we have everything in place to make a join between customer and its orders and create a query that will monitor incoming orders and list them with associated customer fields.

[source,bash,indent=0]
----
ksql> SELECT order_number,quantity,customers.first_name,customers.last_name FROM orders left join customers on orders.purchaser=customers.id;
10001 | 1 | Sally | Thomas
10002 | 2 | George | Bailey
10003 | 2 | George | Bailey
10004 | 1 | Edward | Walker
----

Let's create few events in database
[source,bash,indent=0]
----
docker-compose -f docker-compose-mysql.yaml exec mysql bash -c 'mysql -u $MYSQL_USER -p$MYSQL_PASSWORD inventory'

mysql> INSERT INTO orders VALUES(default,NOW(), 1003,5,101);
Query OK, 1 row affected, 1 warning (0.02 sec)

mysql> UPDATE customers SET first_name='Annie' WHERE id=1004;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> UPDATE orders SET quantity=20 WHERE order_number=10004;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0
----

You may notice that only chanes in `orders` table have triggered changes in the joined stream.
This is a product of the stream/table join.
We would need stream/stream join to trigger change if any of input streams is modified.

So the final result of the select after the database is modified is
[source,bash,indent=0]
----
10001 | 1 | Sally | Thomas
10002 | 2 | George | Bailey
10003 | 2 | George | Bailey
10004 | 1 | Edward | Walker
10005 | 5 | Edward | Walker
10004 | 20 | Edward | Walker
----

== Summary

We have successfully started a KSQL instance. We have mapped KSQL streams to Debezium topics filled by Debezium and made a join between them.
We have also discussed a problem of repartioning in streaming applications.

If you'd like to try out this example with Avro encoding and schema registry then you can use our https://github.com/debezium/debezium-examples/blob/master/tutorial/docker-compose-mysql-avro.yaml[Avro example]. Also for further details and more advanced use just refer to KSQL https://github.com/confluentinc/ksql/blob/master/docs/syntax-reference.md[syntax reference].

In case you need help, have feature requests or would like to share your experiences with this example, please let us know in the comments below.

== About Debezium

Debezium is an open source distributed platform that turns your existing databases into event streams,
so applications can see and respond almost instantly to each committed row-level change in the databases.
Debezium is built on top of http://kafka.apache.org/[Kafka] and provides http://kafka.apache.org/documentation.html#connect[Kafka Connect] compatible connectors that monitor specific database management systems.
Debezium records the history of data changes in Kafka logs, so your application can be stopped and restarted at any time and can easily consume all of the events it missed while it was not running,
ensuring that all events are processed correctly and completely.
Debezium is link:/license[open source] under the http://www.apache.org/licenses/LICENSE-2.0.html[Apache License, Version 2.0].

== Get involved

We hope you find Debezium interesting and useful, and want to give it a try.
Follow us on Twitter https://twitter.com/debezium[@debezium], https://gitter.im/debezium/user[chat with us on Gitter],
or join our https://groups.google.com/forum/#!forum/debezium[mailing list] to talk with the community.
All of the code is open source https://github.com/debezium/[on GitHub],
so build the code locally and help us improve ours existing connectors and add even more connectors.
If you find problems or have ideas how we can improve Debezium, please let us know or https://issues.jboss.org/projects/DBZ/issues/[log an issue].
