<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Debezium connector for SQL Server :: Debezium Documentation</title>
    <link rel="canonical" href="https://debezium.io/documentation/reference/stable/connectors/sqlserver.html">
    <meta name="generator" content="Antora 3.1.7">
<link rel="stylesheet" href="../../../debezium-antora/css/site.css">
<link rel="stylesheet" href="../../../debezium-antora/css/debezium-antora.css">
<link rel="stylesheet" href="../../../debezium-antora/css/highlightjs-dark.css">
<link rel="stylesheet" href="https://static.jboss.org/css/rhbar.css">
<script src="//static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.js"></script>
<script src="../../../debezium-antora/js/jquery.ba-floatingscrollbar.js"></script>
</head>
<body class="article">
<header class="header">
  <div id="rhbar">
      <a class="jbdevlogo" href="https://developers.redhat.com"></a>
      <a class="rhlogo" href="https://www.redhat.com"></a>
  </div>
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
          <img src="/assets/images/color_white_debezium_type_600px.svg" style="height: 32px; margin-right: 14px;"/>
      </a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="/documentation/faq">FAQ</a>
        <a class="navbar-item" href="/documentation">DOCUMENTATION</a>
        <a class="navbar-item" href="/releases">RELEASES</a>
        <a class="navbar-item" href="/community">COMMUNITY</a>
        <a class="navbar-item" href="/blog">BLOG</a>
      </div>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="reference" data-version="stable">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Debezium 2.7 Documentation</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Getting Started</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../tutorial.html">Tutorial</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../install.html">Installation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../postgres-plugins.html">PostgreSQL Decoding Plugins</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../features.html">Features</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Configuration</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/avro.html">Avro Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/topic-auto-create-config.html">Customizing Topic Auto-Creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/signalling.html">Sending Signals to Debezium</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../configuration/notification.html">Receive notifications from Debezium</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Connectors</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="index.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mysql.html">MySQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mariadb.html">MariaDB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="mongodb.html">MongoDB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="postgresql.html">PostgreSQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="oracle.html">Oracle</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="sqlserver.html">SQL Server</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="db2.html">Db2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="cassandra.html">Cassandra</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="vitess.html">Vitess</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="spanner.html">Spanner</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="informix.html">Informix</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Transformations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/index.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/topic-routing.html">Topic Routing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/event-flattening.html">New Record State Extraction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/mongodb-event-flattening.html">MongoDB New Document State Extraction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/event-changes.html">Event Changes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/outbox-event-router.html">Outbox Event Router</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/mongodb-outbox-event-router.html">MongoDB Outbox Event Router</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/filtering.html">Message Filtering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/schema-change-event-filter.html">Schema Change Event Filtering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/content-based-routing.html">Content-Based Routing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/applying-transformations-selectively.html">Using SMT Predicates to Selectively Apply Transformations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/partition-routing.html">Partition Routing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/header-to-value.html">HeaderToValue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/timezone-converter.html">Timezone Converter</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/timescaledb.html">TimescaleDB Integration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../transformations/convert-cloudevent-to-saveable-form.html">Convert CloudEvents to Saveable Form</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Post Processors</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../post-processors/index.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../post-processors/reselect-columns.html">Reselect Columns</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">API and SPI</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../development/engine.html">Debezium Engine</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../development/converters.html">Custom Converters</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integrations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/serdes.html">Change Event SerDes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/outbox.html">Outbox Quarkus Extension</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/cloudevents.html">CloudEvents</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/tracing.html">OpenTelemetry</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integrations/testcontainers.html">Integration Testing with Testcontainers</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Operations</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/debezium-server.html">Debezium Server</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/monitoring.html">Monitoring</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/kubernetes.html">Running on Kubernetes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/openshift.html">Running on Openshift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../operations/debezium-ui.html">Debezium UI</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Debezium Documentation</span>
    <span class="version">2.7</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Debezium Documentation</span>
      <ul class="versions">
        <li class="version">
          <a href="/documentation/reference/nightly/index.html">nightly</a>
        </li>
        <li class="version is-current">
          <a href="/documentation/reference/2.7/index.html">2.7</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/3.0/index.html">3.0</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.6/index.html">2.6</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.5/index.html">2.5</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.4/index.html">2.4</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.3/index.html">2.3</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.2/index.html">2.2</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.1/index.html">2.1</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/2.0/index.html">2.0</a>
        </li>
        <li class="version">
          <a href="/documentation/reference/1.9/index.html">1.9</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main role="main" class="main">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Debezium Documentation</a></li>
    <li>Connectors</li>
    <li><a href="sqlserver.html">SQL Server</a></li>
  </ul>
</nav>
    <div class="page-versions-container">
    Version:
    <div class="page-versions">
        <button class="version-menu-toggle versions-menu-current" title="Show other versions of page">2.7</button>
        <div class="version-menu">
                <a class="version" href="/documentation/reference/nightly/index.html">nightly</a>
                <a class="version is-current" href="/documentation/reference/2.7/index.html">2.7</a>
                <a class="version" href="/documentation/reference/3.0/index.html">3.0</a>
                <a class="version" href="/documentation/reference/2.6/index.html">2.6</a>
                <a class="version" href="/documentation/reference/2.5/index.html">2.5</a>
                <a class="version" href="/documentation/reference/2.4/index.html">2.4</a>
                <a class="version" href="/documentation/reference/2.3/index.html">2.3</a>
                <a class="version" href="/documentation/reference/2.2/index.html">2.2</a>
                <a class="version" href="/documentation/reference/2.1/index.html">2.1</a>
                <a class="version" href="/documentation/reference/2.0/index.html">2.0</a>
                <a class="version" href="/documentation/reference/1.9/index.html">1.9</a>
        </div>
        |
    </div>
    </div>
  <div class="edit-this-page"><a href="https://github.com/debezium/debezium/edit/2.7/documentation/modules/ROOT/pages/connectors/sqlserver.adoc">Edit this Page</a></div>
  </div>
<div class="article-grid">
<div class="article-cell1">
<article class="doc">
        
    <!-- This partial is a placeholder -->            <h1 class="page">Debezium connector for SQL Server</h1>
        <div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Want to help us further hone and improve it? <a href="/docs/contribute/">Learn how</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#sqlserver-overview">Overview</a></li>
<li><a href="#how-the-sqlserver-connector-works">How the SQL Server connector works</a>
<ul class="sectlevel2">
<li><a href="#sqlserver-snapshots">Snapshots</a></li>
<li><a href="#sqlserver-ad-hoc-snapshots">Ad hoc snapshots</a></li>
<li><a href="#sqlserver-incremental-snapshots">Incremental snapshots</a></li>
<li><a href="#connector-custom-snapshot">Custom snapshotter SPI</a></li>
<li><a href="#sqlserver-blocking-snapshots">Blocking snapshots</a></li>
<li><a href="#_reading_the_change_data_tables">Reading the change data tables</a></li>
<li><a href="#_no_maximum_lsn_recorded_in_the_database">No maximum LSN recorded in the database</a></li>
<li><a href="#_limitations">Limitations</a></li>
<li><a href="#sqlserver-topic-names">Topic names</a></li>
<li><a href="#sqlserver-schema-history-topic">Schema history topic</a></li>
<li><a href="#about-the-debezium-sqlserver-connector-schema-change-topic">Schema change topic</a></li>
<li><a href="#_data_change_events">Data change events</a></li>
<li><a href="#sqlserver-transaction-metadata">Transaction metadata</a></li>
<li><a href="#sqlserver-data-types">Data type mappings</a></li>
</ul>
</li>
<li><a href="#setting-up-sqlserver">Setting up SQL Server</a>
<ul class="sectlevel2">
<li><a href="#_enabling_cdc_on_the_sql_server_database">Enabling CDC on the SQL Server database</a></li>
<li><a href="#_enabling_cdc_on_a_sql_server_table">Enabling CDC on a SQL Server table</a></li>
<li><a href="#_verifying_that_the_user_has_access_to_the_cdc_table">Verifying that the user has access to the CDC table</a></li>
<li><a href="#sqlserver-on-azure">SQL Server on Azure</a></li>
<li><a href="#sqlserver-always-on-replica">SQL Server Always On</a></li>
<li><a href="#_effect_of_sql_server_capture_job_agent_configuration_on_server_load_and_latency">Effect of SQL Server capture job agent configuration on server load and latency</a></li>
<li><a href="#_sql_server_capture_job_agent_configuration_parameters">SQL Server capture job agent configuration parameters</a></li>
</ul>
</li>
<li><a href="#sqlserver-deploying-a-connector">Deployment</a>
<ul class="sectlevel2">
<li><a href="#sqlserver-example-configuration">SQL Server connector configuration example</a></li>
<li><a href="#sqlserver-adding-connector-configuration">Adding connector configuration</a></li>
<li><a href="#sqlserver-connector-properties">Connector properties</a></li>
</ul>
</li>
<li><a href="#sqlserver-schema-evolution">Database schema evolution</a>
<ul class="sectlevel2">
<li><a href="#offline-schema-updates">Offline schema updates</a></li>
<li><a href="#online-schema-updates">Online schema updates</a></li>
</ul>
</li>
<li><a href="#sqlserver-monitoring">Monitoring</a>
<ul class="sectlevel2">
<li><a href="#customized-mbean-names">Customized MBean names</a></li>
<li><a href="#sqlserver-snapshot-metrics">Snapshot metrics</a></li>
<li><a href="#sqlserver-streaming-metrics">Streaming metrics</a></li>
<li><a href="#sqlserver-schema-history-metrics">Schema history metrics</a></li>
</ul>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Debezium SQL Server connector captures row-level changes that occur in the schemas of a SQL Server database.</p>
</div>
<div class="paragraph">
<p>For information about the SQL Server versions that are compatible with this connector, see the <a href="https://debezium.io/releases/">Debezium release overview</a>.</p>
</div>
<div class="paragraph">
<p>The first time that the Debezium SQL Server connector connects to a SQL Server database or cluster, it takes a consistent snapshot of the schemas in the database.
After the initial snapshot is complete, the connector continuously captures row-level changes for <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operations that are committed to the SQL Server databases that are enabled for CDC.
The connector produces events for each data change operation, and streams them to Kafka topics.
The connector streams all of the events for a table to a dedicated Kafka topic.
Applications and services can then consume data change event records from that topic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sqlserver-overview"><a class="anchor" href="#sqlserver-overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Debezium SQL Server connector is based on the <a href="https://docs.microsoft.com/en-us/sql/relational-databases/track-changes/about-change-data-capture-sql-server?view=sql-server-2017">change data capture</a>
feature that is available in <a href="https://blogs.msdn.microsoft.com/sqlreleaseservices/sql-server-2016-service-pack-1-sp1-released/">SQL Server 2016 Service Pack 1 (SP1) and later</a> Standard edition or Enterprise edition.
The SQL Server capture process monitors designated databases and tables, and stores the changes into specifically created <em>change tables</em> that have stored procedure facades.</p>
</div>
<div class="paragraph">
<p>To enable the Debezium SQL Server connector to capture change event records for database operations,
you must first enable change data capture on the SQL Server database.
CDC must be enabled on both the database and on each table that you want to capture.
After you set up CDC on the source database, the connector can capture row-level <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations
that occur in the database.
The connector writes event records for each source table to a Kafka topic especially dedicated to that table.
One topic exists for each captured table.
Client applications read the Kafka topics for the database tables that they follow, and can respond to the row-level events they consume from those topics.</p>
</div>
<div class="paragraph">
<p>The first time that the connector connects to a SQL Server database or cluster, it takes a consistent snapshot of the schemas for all tables for which it is configured to capture changes,
and streams this state to Kafka.
After the snapshot is complete, the connector continuously captures subsequent row-level changes that occur.
By first establishing a consistent view of all of the data, the connector can continue reading without having lost any of the changes that were made while the snapshot was taking place.</p>
</div>
<div class="paragraph">
<p>The Debezium SQL Server connector is tolerant of failures.
As the connector reads changes and produces events, it periodically records the position of events in the database log (<em>LSN / Log Sequence Number</em>).
If the connector stops for any reason (including communication failures, network problems, or crashes), after a restart the connector resumes reading the SQL Server <em>CDC</em> tables from the last point that it read.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Offsets are committed periodically.
They are not committed at the time that a change event occurs.
As a result, following an outage, duplicate events might be generated.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Fault tolerance also applies to snapshots.
That is, if the connector stops during a snapshot, the connector begins a new snapshot when it restarts.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-the-sqlserver-connector-works"><a class="anchor" href="#how-the-sqlserver-connector-works"></a>How the SQL Server connector works</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To optimally configure and run a Debezium SQL Server connector, it is helpful to understand how the connector performs snapshots, streams change events, determines Kafka topic names, and uses metadata.</p>
</div>
<div class="sect2">
<h3 id="sqlserver-snapshots"><a class="anchor" href="#sqlserver-snapshots"></a>Snapshots</h3>
<div class="paragraph">
<p>SQL Server CDC is not designed to store a complete history of database changes.
For the Debezium SQL Server connector to establish a baseline for the current state of the database, it uses a process called <em>snapshotting</em>.
The initial snapshot captures the structure and data of the tables in the database.</p>
</div>
<div class="sect3">
<h4 id="sqlserver-default-workflow-for-performing-an-initial-snapshot"><a class="anchor" href="#sqlserver-default-workflow-for-performing-an-initial-snapshot"></a>Default workflow that the Debezium SQL Server connector uses to perform an initial snapshot</h4>
<div class="paragraph">
<p>The following workflow lists the steps that Debezium takes to create a snapshot.
These steps describe the process for a snapshot when the <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> configuration property is set to its default value, which is <code>initial</code>.
You can customize the way that the connector creates snapshots by changing the value of the <code>snapshot.mode</code> property.
If you configure a different snapshot mode, the connector completes the snapshot by using a modified version of this workflow.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Establish a connection to the database.</p>
</li>
<li>
<p>Determine the tables to be captured.
By default, the connector captures all non-system tables.
To have the connector capture a subset of tables or table elements, you can set a number of <code>include</code> and <code>exclude</code> properties to filter the data, for example, <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> or <a href="#sqlserver-property-table-exclude-list"><code>table.exclude.list</code></a>.</p>
</li>
<li>
<p>Obtain a lock on the SQL Server tables for which CDC is enabled to prevent structural changes from occurring during creation of the snapshot.
The level of the lock is determined by the <a href="#sqlserver-property-snapshot-isolation-mode"><code>snapshot.isolation.mode</code></a> configuration property.</p>
</li>
<li>
<p>Read the maximum log sequence number (LSN) position in the server&#8217;s transaction log.</p>
</li>
<li>
<p>Capture the structure of all non-system, or all tables that are designated for capture.
The connector persists this information in its internal database schema history topic.
The schema history provides information about the structure that is in effect when a change event occurs.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the connector captures the schema of every table in the database that is in capture mode, including tables that are not configured for capture.
If tables are not configured for capture, the initial snapshot captures only their structure; it does not capture any table data.
For more information about why snapshots persist schema information for tables that you did not include in the initial snapshot, see <a href="#understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables">Understanding why initial snapshots capture the schema for all tables</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Release the locks obtained in Step 3, if necessary.
Other database clients can now write to any previously locked tables.</p>
</li>
<li>
<p>At the LSN position read in Step 4, the connector scans the tables to be captured.
During the scan, the connector completes the following tasks:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Confirms that the table was created before the snapshot began.
If the table was created after the snapshot began, the connector skips the table.
After the snapshot is complete, and the connector transitions to streaming, it emits change events for any tables that were created after the snapshot began.</p>
</li>
<li>
<p>Produces a <code>read</code> event for each row that is captured from a table.
All <code>read</code> events contain the same LSN position, which is the LSN position that was obtained in step 4.</p>
</li>
<li>
<p>Emits each <code>read</code> event to the Kafka topic for the table.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Records the successful completion of the snapshot in the connector offsets.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting initial snapshot captures the current state of each row in the tables that are enabled for CDC.
From this baseline state, the connector captures subsequent changes as they occur.</p>
</div>
<div class="paragraph">
<p>After the snapshot process begins, if the process is interrupted due to connector failure, rebalancing, or other reasons, the process restarts after the connector restarts.</p>
</div>
<div class="paragraph">
<p>After the connector completes the initial snapshot, it continues streaming from the position that it read in Step 4 so that it does not miss any updates.</p>
</div>
<div class="paragraph">
<p>If the connector stops again for any reason, after it restarts, it resumes streaming changes from where it previously left off.</p>
</div>
<table id="sqlserver-connector-snapshot-mode-options" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Settings for <code>snapshot.mode</code> connector configuration property</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>always</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Perform snapshot on each connector start.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>initial</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The connector performs a database snapshot as described in the <a href="#sqlserver-default-workflow-for-performing-an-initial-snapshot">default workflow for creating an initial snapshot</a>.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>initial_only</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The connector performs a database snapshot and stops before streaming any change event records, not allowing any subsequent change events to be captured.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>schema_only</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Deprecated, see <code>no_data</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>no_data</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The connector captures the structure of all relevant tables, performing all the steps described in the <a href="#sqlserver-default-workflow-for-performing-an-initial-snapshot">default snapshot workflow</a>, except that it does not create <code>READ</code> events to represent the data set at the point of the connector&#8217;s start-up (Step 7.b).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>recovery</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth.<br></p>
</div>
<div class="paragraph">
<p>+
WARNING: Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>when_needed</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>After the connector starts, it performs a snapshot only if it detects one of the following circumstances:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It cannot detect any topic offsets.</p>
</li>
<li>
<p>A previously recorded offset specifies a log position that is not available on the server.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>configuration_based</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Set the snapshot mode to <code>configuration_based</code> to control snapshot behavior through the set of connector properties that have the prefix 'snapshot.mode.configuration.based'.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>custom</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The <code>custom</code> snapshot mode lets you inject your own implementation of the <code>io.debezium.spi.snapshot.Snapshotter</code> interface.
Set the <code>snapshot.mode.custom.name</code> configuration property to the name provided by the <code>name()</code> method of your implementation.
The name is specified on the classpath of your Kafka Connect cluster.
If you use the Debezium <code>EmbeddedEngine</code>, the name is included in the connector JAR file.
For more information, see <a href="#connector-custom-snapshot">custom snapshotter SPI</a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For more information, see <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> in the table of connector configuration properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"><a class="anchor" href="#understanding-why-initial-snapshots-capture-the-schema-history-for-all-tables"></a>Understanding why initial snapshots capture the schema history for all tables</h4>
<div class="paragraph">
<p>The initial snapshot that a connector runs captures two types of information:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Table data</dt>
<dd>
<p>Information about <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations in tables that are named in the connector&#8217;s <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> property.</p>
</dd>
<dt class="hdlist1">Schema data</dt>
<dd>
<p>DDL statements that describe the structural changes that are applied to tables.
Schema data is persisted to both the internal schema history topic, and to the connector&#8217;s schema change topic, if one is configured.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>After you run an initial snapshot, you might notice that the snapshot captures schema information for tables that are not designated for capture.
By default, initial snapshots are designed to capture schema information for every table that is present in the database, not only from tables that are designated for capture.
Connectors require that the table&#8217;s schema is present in the schema history topic before they can capture a table.
By enabling the initial snapshot to capture schema data for tables that are not part of the original capture set, Debezium prepares the connector to readily capture event data from these tables should that later become necessary.
If the initial snapshot does not capture a table&#8217;s schema, you must add the schema to the history topic before the connector can capture data from the table.</p>
</div>
<div class="paragraph">
<p>In some cases, you might want to limit schema capture in the initial snapshot.
This can be useful when you want to reduce the time required to complete a snapshot.
Or when Debezium connects to the database instance through a user account that has access to multiple logical databases, but you want the connector to capture changes only from tables in a specific logic database.</p>
</div>
<div class="ulist">
<div class="title">Additional information</div>
<ul>
<li>
<p><a href="#sqlserver-capturing-data-from-tables-not-captured-by-the-initial-snapshot">Capturing data from tables not captured by the initial snapshot (no schema change)</a></p>
</li>
<li>
<p><a href="#sqlserver-capturing-data-from-new-tables-with-schema-changes">Capturing data from tables not captured by the initial snapshot (schema change)</a></p>
</li>
<li>
<p>Setting the <a href="#sqlserver-property-database-history-store-only-captured-tables-ddl"><code>schema.history.internal.store.only.captured.tables.ddl</code></a> property to specify the tables from which to capture schema information.</p>
</li>
<li>
<p>Setting the <a href="#sqlserver-property-database-history-store-only-captured-databases-ddl"><code>schema.history.internal.store.only.captured.databases.ddl</code></a> property to specify the logical databases from which to capture schema changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="sqlserver-capturing-data-from-tables-not-captured-by-the-initial-snapshot"><a class="anchor" href="#sqlserver-capturing-data-from-tables-not-captured-by-the-initial-snapshot"></a>Capturing data from tables not captured by the initial snapshot (no schema change)</h4>
<div class="paragraph">
<p>In some cases, you might want the connector to capture data from a table whose schema was not captured by the initial snapshot.
Depending on the connector configuration, the initial snapshot might capture the table schema only for specific tables in the database.
If the table schema is not present in the history topic, the connector fails to capture the table, and reports a missing schema error.</p>
</div>
<div class="paragraph">
<p>You might still be able to capture data from the table, but you must perform additional steps to add the table schema.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.</p>
</li>
<li>
<p>No schema changes were applied to the table between the LSNs of the earliest and latest change table entry that the connector reads.
For information about capturing data from a new table that has undergone structural changes, see <a href="#db2-capturing-data-from-new-tables-with-schema-changes">[db2-capturing-data-from-new-tables-with-schema-changes]</a>.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Stop the connector.</p>
</li>
<li>
<p>Remove the internal database schema history topic that is specified by the <a href="#sqlserver-property-database-history-kafka-topic"><code>schema.history.internal.kafka.topic property</code></a>.</p>
</li>
<li>
<p>Clear the offsets in the configured Kafka Connect <a href="https://kafka.apache.org/documentation/#connectconfigs_offset.storage.topic"><code>offset.storage.topic</code></a>.
For more information about how to remove offsets, see the <a href="https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector">Debezium community FAQ</a>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Apply the following changes to the connector configuration:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>(Optional) Set the value of <a href="#sqlserver-property-database-history-store-only-captured-tables-ddl"><code>schema.history.internal.store.only.captured.tables.ddl</code></a> to <code>false</code>.
This setting causes the snapshot to capture the schema for all tables, and guarantees that, in the future, the connector can reconstruct the schema history for all tables.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Snapshots that capture the schema for all tables require more time to complete.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Add the tables that you want the connector to capture to <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a>.</p>
</li>
<li>
<p>Set the <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> to one of the following values:</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>initial</code></dt>
<dd>
<p>When you restart the connector, it takes a full snapshot of the database that captures the table data and table structures.<br>
If you select this option, consider setting the value of the <a href="#sqlserver-property-database-history-store-only-captured-tables-ddl"><code>schema.history.internal.store.only.captured.tables.ddl</code></a> property to <code>false</code> to enable the connector to capture the schema of all tables.</p>
</dd>
<dt class="hdlist1"><code>schema_only</code></dt>
<dd>
<p>When you restart the connector, it takes a snapshot that captures only the table schema.
Unlike a full data snapshot, this option does not capture any table data.
Use this option if you want to restart the connector more quickly than with a full snapshot.</p>
</dd>
</dl>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Restart the connector.
The connector completes the type of snapshot specified by the <code>snapshot.mode</code>.</p>
</li>
<li>
<p>(Optional) If the connector performed a <code>schema_only</code> snapshot, after the snapshot completes, initiate an <a href="#sqlserver-incremental-snapshots">incremental snapshot</a> to capture data from the tables that you added.
The connector runs the snapshot while it continues to stream real-time changes from the tables.
Running an incremental snapshot captures the following data changes:</p>
<div class="ulist">
<ul>
<li>
<p>For tables that the connector previously captured, the incremental snapsot captures changes that occur while the connector was down, that is, in the interval between the time that the connector was stopped, and the current restart.</p>
</li>
<li>
<p>For newly added tables, the incremental snapshot captures all existing table rows.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="sqlserver-capturing-data-from-new-tables-with-schema-changes"><a class="anchor" href="#sqlserver-capturing-data-from-new-tables-with-schema-changes"></a>Capturing data from tables not captured by the initial snapshot (schema change)</h4>
<div class="paragraph">
<p>If a schema change is applied to a table, records that are committed before the schema change have different structures than those that were committed after the change.
When Debezium captures data from a table, it reads the schema history to ensure that it applies the correct schema to each event.
If the schema is not present in the schema history topic, the connector is unable to capture the table, and an error results.</p>
</div>
<div class="paragraph">
<p>If you want to capture data from a table that was not captured by the initial snapshot, and the schema of the table was modified, you must add the schema to the history topic, if it is not already available.
You can add the schema by running a new schema snapshot, or by running an initial snapshot for the table.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You want to capture data from a table with a schema that the connector did not capture during the initial snapshot.</p>
</li>
<li>
<p>A schema change was applied to the table so that the records to be captured do not have a uniform structure.</p>
</li>
</ul>
</div>
<div class="dlist">
<div class="title">Procedure</div>
<dl>
<dt class="hdlist1">Initial snapshot captured the schema for all tables (<code>store.only.captured.tables.ddl</code> was set to <code>false</code>)</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Edit the <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> property to specify the tables that you want to capture.</p>
</li>
<li>
<p>Restart the connector.</p>
</li>
<li>
<p>Initiate an <a href="#sqlserver-incremental-snapshots">incremental snapshot</a> if you want to capture existing data from the newly added tables.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Initial snapshot did not capture the schema for all tables (<code>store.only.captured.tables.ddl</code> was set to <code>true</code>)</dt>
<dd>
<p>If the initial snapshot did not save the schema of the table that you want to capture, complete one of the following procedures:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Procedure 1: Schema snapshot, followed by incremental snapshot</dt>
<dd>
<p>In this procedure, the connector first performs a schema snapshot.
You can then initiate an incremental snapshot to enable the connector to synchronize data.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Stop the connector.</p>
</li>
<li>
<p>Remove the internal database schema history topic that is specified by the <a href="#sqlserver-property-database-history-kafka-topic"><code>schema.history.internal.kafka.topic property</code></a>.</p>
</li>
<li>
<p>Clear the offsets in the configured Kafka Connect <a href="https://kafka.apache.org/documentation/#connectconfigs_offset.storage.topic"><code>offset.storage.topic</code></a>.
For more information about how to remove offsets, see the <a href="https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector">Debezium community FAQ</a>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Set values for properties in the connector configuration as described in the following steps:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Set the value of the <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> property to <code>schema_only</code>.</p>
</li>
<li>
<p>Edit the <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> to add the tables that you want to capture.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Restart the connector.</p>
</li>
<li>
<p>Wait for Debezium to capture the schema of the new and existing tables.
Data changes that occurred any tables after the connector stopped are not captured.</p>
</li>
<li>
<p>To ensure that no data is lost, initiate an <a href="#sqlserver-incremental-snapshots">incremental snapshot</a>.</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Procedure 2: Initial snapshot, followed by optional incremental snapshot</dt>
<dd>
<p>In this procedure the connector performs a full initial snapshot of the database.
As with any initial snapshot, in a database with many large tables, running an initial snapshot can be a time-consuming operation.
After the snapshot completes, you can optionally trigger an incremental snapshot to capture any changes that occur while the connector is off-line.</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Stop the connector.</p>
</li>
<li>
<p>Remove the internal database schema history topic that is specified by the <a href="#sqlserver-property-database-history-kafka-topic"><code>schema.history.internal.kafka.topic property</code></a>.</p>
</li>
<li>
<p>Clear the offsets in the configured Kafka Connect <a href="https://kafka.apache.org/documentation/#connectconfigs_offset.storage.topic"><code>offset.storage.topic</code></a>.
For more information about how to remove offsets, see the <a href="https://debezium.io/documentation/faq/#how_to_remove_committed_offsets_for_a_connector">Debezium community FAQ</a>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Removing offsets should be performed only by advanced users who have experience in manipulating internal Kafka Connect data.
This operation is potentially destructive, and should be performed only as a last resort.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Edit the <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> to add the tables that you want to capture.</p>
</li>
<li>
<p>Set values for properties in the connector configuration as described in the following steps:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Set the value of the <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> property to <code>initial</code>.</p>
</li>
<li>
<p>(Optional) Set <a href="#sqlserver-property-database-history-store-only-captured-tables-ddl"><code>schema.history.internal.store.only.captured.tables.ddl</code></a> to <code>false</code>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Restart the connector.
The connector takes a full database snapshot.
After the snapshot completes, the connector transitions to streaming.</p>
</li>
<li>
<p>(Optional) To capture any data that changed while the connector was off-line, initiate an <a href="#sqlserver-incremental-snapshots">incremental snapshot</a>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-ad-hoc-snapshots"><a class="anchor" href="#sqlserver-ad-hoc-snapshots"></a>Ad hoc snapshots</h3>
<div class="paragraph">
<p>By default, a connector runs an initial snapshot operation only after it starts for the first time.
Following this initial snapshot, under normal circumstances, the connector does not repeat the snapshot process.
Any future change event data that the connector captures comes in through the streaming process only.</p>
</div>
<div class="paragraph">
<p>However, in some situations the data that the connector obtained during the initial snapshot might become stale, lost, or incomplete.
To provide a mechanism for recapturing table data, Debezium includes an option to perform ad hoc snapshots.
You might want to perform an ad hoc snapshot after any of the following changes occur in your Debezium environment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The connector configuration is modified to capture a different set of tables.</p>
</li>
<li>
<p>Kafka topics are deleted and must be rebuilt.</p>
</li>
<li>
<p>Data corruption occurs due to a configuration error or some other problem.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can re-run a snapshot for a table for which you previously captured a snapshot by initiating a so-called <em>ad-hoc snapshot</em>.
Ad hoc snapshots require the use of <a href="../configuration/signalling.html#sending-signals-to-a-debezium-connector" class="xref page">signaling tables</a>.
You initiate an ad hoc snapshot by sending a signal request to the Debezium signaling table.</p>
</div>
<div class="paragraph">
<p>When you initiate an ad hoc snapshot of an existing table, the connector appends content to the topic that already exists for the table.
If a previously existing topic was removed, Debezium can create a topic automatically if <a href="../configuration/topic-auto-create-config.html#customizing-debezium-automatically-created-topics" class="xref page">automatic topic creation</a> is enabled.</p>
</div>
<div class="paragraph">
<p>Ad hoc snapshot signals specify the tables to include in the snapshot.
The snapshot can capture the entire contents of the database, or capture only a subset of the tables in the database.
Also, the snapshot can capture a subset of the contents of the table(s) in the database.</p>
</div>
<div class="paragraph">
<p>You specify the tables to capture by sending an <code>execute-snapshot</code> message to the signaling table.
Set the type of the <code>execute-snapshot</code> signal to <code>incremental</code> or <code>blocking</code>, and provide the names of the tables to include in the snapshot, as described in the following table:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Example of an ad hoc <code>execute-snapshot</code> signal record</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>incremental</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the type of snapshot that you want to run.<br>
Currently, you can request <code>incremental</code> or <code>blocking</code> snapshots.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data-collections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An array that contains regular expressions matching the fully-qualified names of the tables to include in the snapshot.<br>
For the SQL Server connector, use the following format to specify the fully qualified name of a table: <code>database.schema.table</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>additional-conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot.<br>
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>data-collection</code></dt>
<dd>
<p>The fully-qualified name of the table that the filter applies to.
You can apply different filters to each table.</p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p>Specifies column values that must be present in a database record for the snapshot to include it, for example,  <code>"color='blue'"</code>.<br>
<br>
The values that you assign to the <code>filter</code> parameter are the same types of values that you might specify in the <code>WHERE</code> clause of <code>SELECT</code> statements when you set the <code>snapshot.select.statement.overrides</code> property for a blocking snapshot.</p>
</dd>
</dl>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>surrogate-key</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional string that specifies the column name that the connector uses as the primary key of a table during the snapshot process.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">Triggering an ad hoc incremental snapshot</div>
<p>You initiate an ad hoc incremental snapshot by adding an entry with the <code>execute-snapshot</code> signal type to the signaling table, or by <a href="#sqlserver-triggering-an-incremental-snapshot-kafka">sending a signal message to a Kafka signaling topic</a>.
After the connector processes the message, it begins the snapshot operation.
The snapshot process reads the first and last primary key values and uses those values as the start and end point for each table.
Based on the number of entries in the table, and the configured chunk size, Debezium divides the table into chunks, and proceeds to snapshot each chunk, in succession, one at a time.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#debezium-sqlserver-incremental-snapshots">Incremental snapshots</a>.</p>
</div>
<div class="paragraph">
<div class="title">Triggering an ad hoc blocking snapshot</div>
<p>You initiate an ad hoc blocking snapshot by adding an entry with the <code>execute-snapshot</code> signal type to the signaling table or signaling topic.
After the connector processes the message, it begins the snapshot operation.
The connector temporarily stops streaming, and then initiates a snapshot of the specified table, following the same process that it uses during an initial snapshot.
After the snapshot completes, the connector resumes streaming.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#sqlserver-blocking-snapshots">Blocking snapshots</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-incremental-snapshots"><a class="anchor" href="#sqlserver-incremental-snapshots"></a>Incremental snapshots</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">SQL Server collations</div>
<div class="paragraph">
<p>Each SQL Server server or database is configured to use a specific <a href="https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16#Collation_Defn">collation</a>, which determines how character data is stored, sorted, compared, and displayed.
The sorting rules for some collation sets, such as the <a href="https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16#SQL-collations">SQL Server collations (SQL_*)</a> are not compatible with the Unicode sorting algorithm.
In some cases, the incompatible sorting rules can lead to lost data when the connector runs an ad hoc snapshot.
For example, if SQL Server is configured to send strings as Unicode (that is, the connection property <code>sendStringParametersAsUnicode</code> is set to <code>true</code>), the connector can skip records during the snapshot.
To protect against lost data during an ad hoc snapshot, set the value of the <code>driver.sendStringParametersAsUnicode</code> connection string property to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>For more information about using the <code>sendStringParametersAsUnicode</code> property, see the <a href="https://learn.microsoft.com/en-us/sql/connect/jdbc/setting-the-connection-properties?view=sql-server-ver16">SQL Server connection properties documentation</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To provide flexibility in managing snapshots, Debezium includes a supplementary snapshot mechanism, known as <em>incremental snapshotting</em>.
Incremental snapshots rely on the Debezium mechanism for <a href="../configuration/signalling.html#sending-signals-to-a-debezium-connector" class="xref page">sending signals to a Debezium connector</a>.
Incremental snapshots are based on the <a href="https://github.com/debezium/debezium-design-documents/blob/main/DDD-3.md">DDD-3</a> design document.</p>
</div>
<div class="paragraph">
<p>In an incremental snapshot, instead of capturing the full state of a database all at once, as in an initial snapshot, Debezium captures each table in phases, in a series of configurable chunks.
You can specify the tables that you want the snapshot to capture and the <a href="#sqlserver-property-incremental-snapshot-chunk-size">size of each chunk</a>.
The chunk size determines the number of rows that the snapshot collects during each fetch operation on the database.
The default chunk size for incremental snapshots is 1024 rows.</p>
</div>
<div class="paragraph">
<p>As an incremental snapshot proceeds, Debezium uses watermarks to track its progress, maintaining a record of each table row that it captures.
This phased approach to capturing data provides the following advantages over the standard initial snapshot process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can run incremental snapshots in parallel with streamed data capture, instead of postponing streaming until the snapshot completes.
The connector continues to capture near real-time events from the change log throughout the snapshot process, and neither operation blocks the other.</p>
</li>
<li>
<p>If the progress of an incremental snapshot is interrupted, you can resume it without losing any data.
After the process resumes, the snapshot begins at the point where it stopped, rather than recapturing the table from the beginning.</p>
</li>
<li>
<p>You can run an incremental snapshot on demand at any time, and repeat the process as needed to adapt to database updates.
For example, you might re-run a snapshot after you modify the connector configuration to add a table to its <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> property.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Incremental snapshot process</div>
<p>When you run an incremental snapshot, Debezium sorts each table by primary key and then splits the table into chunks based on the <a href="#sqlserver-property-incremental-snapshot-chunk-size">configured chunk size</a>.
Working chunk by chunk, it then captures each table row in a chunk.
For each row that it captures, the snapshot emits a <code>READ</code> event.
That event represents the value of the row when the snapshot for the chunk began.</p>
</div>
<div class="paragraph">
<p>As a snapshot proceeds, it’s likely that other processes continue to access the database, potentially modifying table records.
To reflect such changes, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operations are committed to the transaction log as per usual.
Similarly, the ongoing Debezium streaming process continues to detect these change events and emits corresponding change event records to Kafka.</p>
</div>
<div class="paragraph">
<div class="title">How Debezium resolves collisions among records with the same primary key</div>
<p>In some cases, the <code>UPDATE</code> or <code>DELETE</code> events that the streaming process emits are received out of sequence.
That is, the streaming process might emit an event that modifies a table row before the snapshot captures the chunk that contains the <code>READ</code> event for that row.
When the snapshot eventually emits the corresponding <code>READ</code> event for the row, its value is already superseded.
To ensure that incremental snapshot events that arrive out of sequence are processed in the correct logical order, Debezium employs a buffering scheme for resolving collisions.
Only after collisions between the snapshot events and the streamed events are resolved does Debezium emit an event record to Kafka.</p>
</div>
<div class="paragraph">
<div class="title">Snapshot window</div>
<p>To assist in resolving collisions between late-arriving <code>READ</code> events and streamed events that modify the same table row, Debezium employs a so-called <em>snapshot window</em>.
The snapshot window demarcates the interval during which an incremental snapshot captures data for a specified table chunk.
Before the snapshot window for a chunk opens, Debezium follows its usual behavior and emits events from the transaction log directly downstream to the target Kafka topic.
But from the moment that the snapshot for a particular chunk opens, until it closes, Debezium performs a de-duplication step to resolve collisions between events that have the same primary key..</p>
</div>
<div class="paragraph">
<p>For each data collection, the Debezium emits two types of events, and stores the records for them both in a single destination Kafka topic.
The snapshot records that it  captures directly from a table are emitted as <code>READ</code> operations.
Meanwhile, as users continue to update records in the data collection, and the transaction log is updated to reflect each commit, Debezium emits <code>UPDATE</code> or <code>DELETE</code> operations for each change.</p>
</div>
<div class="paragraph">
<p>As the snapshot window opens, and Debezium begins processing a snapshot chunk, it delivers snapshot records to a memory buffer.
During the snapshot windows, the primary keys of the <code>READ</code> events in the buffer are compared to the primary keys of the incoming streamed events.
If no match is found, the streamed event record is sent directly to Kafka.
If Debezium detects a match, it discards the buffered <code>READ</code> event, and writes the streamed record to the destination topic, because the streamed event logically supersede the static snapshot event.
After the snapshot window for the chunk closes, the buffer contains only <code>READ</code> events for which no related transaction log events exist.
Debezium emits these remaining <code>READ</code> events to the table&#8217;s Kafka topic.</p>
</div>
<div class="paragraph">
<p>The connector repeats the process for each snapshot chunk.</p>
</div>
<div class="paragraph">
<p>Currently, you can use either of the following methods to initiate an incremental snapshot:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sqlserver-triggering-an-incremental-snapshot">Send an ad hoc snapshot signal to the signaling table on the source database</a>.</p>
</li>
<li>
<p><a href="#sqlserver-triggering-an-incremental-snapshot-kafka">Send a message to a configured Kafka signaling topic</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Debezium connector for SQL Server does not support schema changes while an incremental snapshot is running.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-triggering-an-incremental-snapshot"><a class="anchor" href="#sqlserver-triggering-an-incremental-snapshot"></a>Triggering an incremental snapshot</h4>
<div class="paragraph">
<p>To initiate an incremental snapshot, you can send an <a href="../configuration/signalling.html#debezium-signaling-ad-hoc-snapshots" class="xref page">ad hoc snapshot signal</a> to the signaling table on the source database.
You submit snapshot signals as SQL <code>INSERT</code> queries.</p>
</div>
<div class="paragraph">
<p>After Debezium detects the change in the signaling table, it reads the signal, and runs the requested snapshot operation.</p>
</div>
<div class="paragraph">
<p>The query that you submit specifies the tables to include in the snapshot, and, optionally, specifies the type of snapshot operation.
Debezium currently supports the <code>incremental</code> and <code>blocking</code> snapshot types.</p>
</div>
<div class="paragraph">
<p>To specify the tables to include in the snapshot, provide a <code>data-collections</code> array that lists the tables, or an array of regular expressions used to match tables, for example,<br></p>
</div>
<div class="paragraph">
<p><code>{"data-collections": ["public.MyFirstTable", "public.MySecondTable"]}</code><br></p>
</div>
<div class="paragraph">
<p>The <code>data-collections</code> array for an incremental snapshot signal has no default value.
If the <code>data-collections</code> array is empty, Debezium interprets the empty array to mean that no action is required, and it does not perform a snapshot.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the name of a table that you want to include in a snapshot contains a dot (<code>.</code>), a space, or some other non-alphanumeric character, you must escape the table name in double quotes.<br>
For example, to include a table that exists in the <code><strong>public</strong></code> schema in the <code><strong>db1</strong></code> database, and that has the name <code><strong>My.Table</strong></code>, use the following format: <code><strong>"db1.public.\"My.Table\""</strong></code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p><a href="../configuration/signalling.html#debezium-signaling-enabling-source-signaling-channel" class="xref page">Signaling is enabled</a>.<br></p>
<div class="ulist">
<ul>
<li>
<p>A signaling data collection exists on the source database.</p>
</li>
<li>
<p>The signaling data collection is specified in the <a href="#sqlserver-property-signal-data-collection"><code>signal.data.collection</code></a> property.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Using a source signaling channel to trigger an incremental snapshot</div>
<ol class="arabic">
<li>
<p>Send a SQL query to add the ad hoc incremental snapshot request to the signaling table:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO <em>&lt;signalTable&gt;</em> (id, type, data) VALUES (<em>'&lt;id&gt;'</em>, <em>'&lt;snapshotType&gt;'</em>, '{"data-collections": ["<em>&lt;fullyQualfiedTableName&gt;</em>","<em>&lt;fullyQualfiedTableName&gt;</em>"],"type":"<em>&lt;snapshotType&gt;</em>","additional-conditions":[{"data-collection": "<em>&lt;fullyQualfiedTableName&gt;</em>", "filter": "<em>&lt;additional-condition&gt;</em>"}]}');</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO db1.myschema.debezium_signal (id, type, data) <i class="conum" data-value="1"></i><b>(1)</b>
values ('ad-hoc-1',   <i class="conum" data-value="2"></i><b>(2)</b>
    'execute-snapshot',  <i class="conum" data-value="3"></i><b>(3)</b>
    '{"data-collections": ["db1.schema1.table1", "db1.schema1.table2"], <i class="conum" data-value="4"></i><b>(4)</b>
    "type":"incremental", <i class="conum" data-value="5"></i><b>(5)</b>
    "additional-conditions":[{"data-collection": "db1.schema1.table1" ,"filter":"color=\'blue\'"}]}'); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>+
The values of the <code>id</code>,<code>type</code>, and <code>data</code> parameters in the command correspond to the <a href="../configuration/signalling.html#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection" class="xref page">fields of the signaling table</a>.</p>
</div>
<div class="paragraph">
<p>+
The following table describes the parameters in the example:</p>
</div>
<div class="paragraph">
<p>+
.Descriptions of fields in a SQL command for sending an incremental snapshot signal to the signaling table</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>database.schema.debezium_signal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the fully-qualified name of the signaling table on the source database.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ad-hoc-1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>id</code> parameter specifies an arbitrary string that is assigned as the <code>id</code> identifier for the signal request.<br>
Use this string to identify logging messages to entries in the signaling table.
Debezium does not use this string.
Rather, during the snapshot, Debezium generates its own <code>id</code> string as a watermarking signal.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>execute-snapshot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>type</code> parameter specifies the operation that the signal is intended to trigger.<br></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data-collections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A required component of the <code>data</code> field of a signal that specifies an array of table names or regular expressions to match table names to include in the snapshot.<br>
The array lists regular expressions that use the format <code>database.schema.table</code> to match the fully-qualified names of the tables.
This format is the same as the one that you use to specify the name of the connector&#8217;s <a href="../configuration/signalling.html#format-for-specifying-fully-qualified-names-for-data-collections" class="xref page">signaling table</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>incremental</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional <code>type</code> component of the <code>data</code> field of a signal that specifies the type of snapshot operation to run.<br>
Valid values are <code>incremental</code> and <code>blocking</code>.<br>
If you do not specify a value, the connector defaults to performing an incremental snapshot.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>additional-conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional array that specifies a set of additional conditions that the connector evaluates to determine the subset of records to include in a snapshot.<br>
Each additional condition is an object with <code>data-collection</code> and <code>filter</code> properties.
You can specify different filters for each data collection.<br>
* The <code>data-collection</code> property is the fully-qualified name of the data collection that the filter applies to.
For more information about the <code>additional-conditions</code> parameter, see <a href="#sqlserver-incremental-snapshots-additional-conditions">Running an ad hoc incremental snapshots with <code>additional-conditions</code></a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-incremental-snapshots-additional-conditions"><a class="anchor" href="#sqlserver-incremental-snapshots-additional-conditions"></a>Running an ad hoc incremental snapshots with <code>additional-conditions</code></h4>
<div class="paragraph">
<p>If you want a snapshot to include only a subset of the content in a table, you can modify the signal request by appending an <code>additional-conditions</code> parameter to the snapshot signal.</p>
</div>
<div class="paragraph">
<p>The SQL query for a typical snapshot takes the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT * FROM <em>&lt;tableName&gt;</em> ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>By adding an <code>additional-conditions</code> parameter, you append a <code>WHERE</code> condition to the SQL query, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT * FROM <em>&lt;data-collection&gt;</em> WHERE <em>&lt;filter&gt;</em> ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a SQL query to send an ad hoc incremental snapshot request with an additional condition to the signaling table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO <em>&lt;signalTable&gt;</em> (id, type, data) VALUES (<em>'&lt;id&gt;'</em>, <em>'&lt;snapshotType&gt;'</em>, '{"data-collections": ["<em>&lt;fullyQualfiedTableName&gt;</em>","<em>&lt;fullyQualfiedTableName&gt;</em>"],"type":"<em>&lt;snapshotType&gt;</em>","additional-conditions":[{"data-collection": "<em>&lt;fullyQualfiedTableName&gt;</em>", "filter": "<em>&lt;additional-condition&gt;</em>"}]}');</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, suppose you have a <code>products</code> table that contains the following columns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> (primary key)</p>
</li>
<li>
<p><code>color</code></p>
</li>
<li>
<p><code>quantity</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want an incremental snapshot of the <code>products</code> table to include only the data items where <code>color=blue</code>, you can use the following SQL statement to trigger the snapshot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO db1.myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["db1.schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "db1.schema1.products", "filter": "color=blue"}]}');</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>additional-conditions</code> parameter also enables you to pass conditions that are based on more than one column.
For example, using the <code>products</code> table from the previous example, you can submit a query that triggers an incremental snapshot that includes the data of only those items for which <code>color=blue</code> and <code>quantity&gt;10</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO db1.myschema.debezium_signal (id, type, data) VALUES('ad-hoc-1', 'execute-snapshot', '{"data-collections": ["db1.schema1.products"],"type":"incremental", "additional-conditions":[{"data-collection": "db1.schema1.products", "filter": "color=blue AND quantity&gt;10"}]}');</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example, shows the JSON for an incremental snapshot event that is captured by a connector.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Incremental snapshot event message</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "before":null,
    "after": {
        "pk":"1",
        "value":"New data"
    },
    "source": {
        ...
        "snapshot":"incremental" <i class="conum" data-value="1"></i><b>(1)</b>
    },
    "op":"r", <i class="conum" data-value="2"></i><b>(2)</b>
    "ts_ms":"1620393591654",
    "ts_us":"1620393591654547",
    "ts_ns":"1620393591654547920",
    "transaction":null
}</code></pre>
</div>
</div>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Description of fields in an incremental snapshot event message</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>snapshot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the type of snapshot operation to run.<br>
Currently, the only valid options are <code>blocking</code> and <code>incremental</code>.<br>
Specifying a <code>type</code> value in the SQL query that you submit to the signaling table is optional.<br>
If you do not specify a value, the connector runs an incremental snapshot.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the event type.<br>
The value for snapshot events is <code>r</code>, signifying a <code>READ</code> operation.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-triggering-an-incremental-snapshot-kafka"><a class="anchor" href="#sqlserver-triggering-an-incremental-snapshot-kafka"></a>Using the Kafka signaling channel to trigger an incremental snapshot</h4>
<div class="paragraph">
<p>You can send a message to the <a href="../configuration/signalling.html#debezium-signaling-enabling-kafka-signaling-channel" class="xref page">configured Kafka topic</a> to request the connector to run an ad hoc incremental snapshot.</p>
</div>
<div class="paragraph">
<p>The key of the Kafka message must match the value of the <code>topic.prefix</code> connector configuration option.</p>
</div>
<div class="paragraph">
<p>The value of the message is a JSON object with <code>type</code> and <code>data</code> fields.</p>
</div>
<div class="paragraph">
<p>The signal type is <code>execute-snapshot</code>, and the <code>data</code> field must have the following fields:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Execute snapshot data fields</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>incremental</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The type of the snapshot to be executed.
Currently Debezium supports the <code>incremental</code> and <code>blocking</code> types.<br>
See the next section for more details.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data-collections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An array of comma-separated regular expressions that match the fully-qualified names of tables to include in the snapshot.<br>
Specify the names by using the same format as is required for the <a href="#sqlserver-property-signal-data-collection">signal.data.collection</a> configuration option.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>additional-conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional array of additional conditions that specifies criteria that the connector evaluates to designate a subset of records to include in a snapshot.<br>
Each additional condition is an object that specifies the criteria for filtering the data that an ad hoc snapshot captures.
You can set the following parameters for each additional condition:
<code>data-collection</code>:: The fully-qualified name of the table that the filter applies to.
You can apply different filters to each table.
<code>filter</code>:: Specifies column values that must be present in a database record for the snapshot to include it, for example,  <code>"color='blue'"</code>.<br>
<br>
The values that you assign to the <code>filter</code> parameter are the same types of values that you might specify in the <code>WHERE</code> clause of <code>SELECT</code> statements when you set the <code>snapshot.select.statement.overrides</code> property for a blocking snapshot.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="exampleblock">
<div class="title">Example 2. An <code>execute-snapshot</code> Kafka message</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["{collection-container}.table1", "{collection-container}.table2"], "type": "INCREMENTAL"}}`</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<div class="title">Ad hoc incremental snapshots with additional-conditions</div>
<p>Debezium uses the <code>additional-conditions</code> field to select a subset of a table&#8217;s content.</p>
</div>
<div class="paragraph">
<p>Typically, when Debezium runs a snapshot, it runs a SQL query such as:</p>
</div>
<div class="paragraph">
<p><code>SELECT * FROM <em>&lt;tableName&gt;</em> &#8230;&#8203;.</code></p>
</div>
<div class="paragraph">
<p>When the snapshot request includes an <code>additional-conditions</code> property, the <code>data-collection</code> and <code>filter</code> parameters of the property are appended to the SQL query, for example:</p>
</div>
<div class="paragraph">
<p><code>SELECT * FROM <em>&lt;data-collection&gt;</em> WHERE <em>&lt;filter&gt;</em> &#8230;&#8203;.</code></p>
</div>
<div class="paragraph">
<p>For example, given a <code>products</code> table with the columns <code>id</code> (primary key), <code>color</code>, and <code>brand</code>, if you want a snapshot to include only content for which <code>color='blue'</code>, when you request the snapshot, you could add the <code>additional-conditions</code> property to filter the content:
:leveloffset: +1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["db1.schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "db1.schema1.products" ,"filter":"color='blue'"}]}}`</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>additional-conditions</code> property to pass conditions based on multiple columns.
For example, using the same <code>products</code> table as in the previous example, if you want a snapshot to include only the content from the <code>products</code> table for which <code>color='blue'</code>, and <code>brand='MyBrand'</code>, you could send the following request:
:leveloffset: +1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">Key = `test_connector`

Value = `{"type":"execute-snapshot","data": {"data-collections": ["db1.schema1.products"], "type": "INCREMENTAL", "additional-conditions": [{"data-collection": "db1.schema1.products" ,"filter":"color='blue' AND brand='MyBrand'"}]}}`</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sqlserver-stopping-an-incremental-snapshot"><a class="anchor" href="#sqlserver-stopping-an-incremental-snapshot"></a>Stopping an incremental snapshot</h4>
<div class="paragraph">
<p>In some situations, it might be necessary to stop an incremental snapshot.
For example, you might realize that snapshot was not configured correctly, or maybe you want to ensure that resources are available for other database operations.
You can stop a snapshot that is already running by sending a signal to the signaling table on the source database.</p>
</div>
<div class="paragraph">
<p>You submit a stop snapshot signal to the signaling table by sending it in a SQL <code>INSERT</code> query.
The stop-snapshot signal specifies the <code>type</code> of the snapshot operation as <code>incremental</code>, and optionally specifies the tables that you want to omit from the currently running snapshot.
After Debezium detects the change in the signaling table, it reads the signal, and stops the incremental snapshot operation if it&#8217;s in progress.</p>
</div>
<div class="paragraph">
<div class="title">Additional resources</div>
<p>You can also stop an incremental snapshot by sending a JSON message to the <a href="#sqlserver-stopping-an-incremental-snapshot-kafka">Kafka signaling topic</a>.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p><a href="../configuration/signalling.html#debezium-signaling-enabling-source-signaling-channel" class="xref page">Signaling is enabled</a>.<br></p>
<div class="ulist">
<ul>
<li>
<p>A signaling data collection exists on the source database.</p>
</li>
<li>
<p>The signaling data collection is specified in the <a href="#sqlserver-property-signal-data-collection"><code>signal.data.collection</code></a> property.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Using a source signaling channel to stop an incremental snapshot</div>
<ol class="arabic">
<li>
<p>Send a SQL query to stop the ad hoc incremental snapshot to the signaling table:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO <em>&lt;signalTable&gt;</em> (id, type, data) values (<em>'&lt;id&gt;'</em>, 'stop-snapshot', '{"data-collections": ["<em>&lt;fullyQualfiedTableName&gt;</em>","<em>&lt;fullyQualfiedTableName&gt;</em>"],"type":"incremental"}');</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO db1.myschema.debezium_signal (id, type, data) <i class="conum" data-value="1"></i><b>(1)</b>
values ('ad-hoc-1',   <i class="conum" data-value="2"></i><b>(2)</b>
    'stop-snapshot',  <i class="conum" data-value="3"></i><b>(3)</b>
    '{"data-collections": ["db1.schema1.table1", "db1.schema1.table2"], <i class="conum" data-value="4"></i><b>(4)</b>
    "type":"incremental"}'); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>+
The values of the <code>id</code>, <code>type</code>, and <code>data</code> parameters in the signal command correspond to the <a href="../configuration/signalling.html#debezium-signaling-description-of-required-structure-of-a-signaling-data-collection" class="xref page">fields of the signaling table</a>.</p>
</div>
<div class="paragraph">
<p>+
The following table describes the parameters in the example:</p>
</div>
<div class="paragraph">
<p>+
.Descriptions of fields in a SQL command for sending a stop incremental snapshot signal to the signaling table</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>database.schema.debezium_signal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the fully-qualified name of the signaling table on the source database.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ad-hoc-1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>id</code> parameter specifies an arbitrary string that is assigned as the <code>id</code> identifier for the signal request.<br>
Use this string to identify logging messages to entries in the signaling table.
Debezium does not use this string.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>stop-snapshot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies <code>type</code> parameter specifies the operation that the signal is intended to trigger.<br></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data-collections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional component of the <code>data</code> field of a signal that specifies an array of table names or regular expressions to match table names to remove from the snapshot.<br>
The array lists regular expressions which match tables by their fully-qualified names in the format <code>database.schema.table</code></p>
<p class="tableblock">If you omit this component from the <code>data</code> field, the signal stops the entire incremental snapshot that is in progress.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>incremental</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A required component of the <code>data</code> field of a signal that specifies the type of snapshot operation that is to be stopped.<br>
Currently, the only valid option is <code>incremental</code>.<br>
If you do not specify a <code>type</code> value, the signal fails to stop the incremental snapshot.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-stopping-an-incremental-snapshot-kafka"><a class="anchor" href="#sqlserver-stopping-an-incremental-snapshot-kafka"></a>Using the Kafka signaling channel to stop an incremental snapshot</h4>
<div class="paragraph">
<p>You can send a signal message to the <a href="../configuration/signalling.html#debezium-signaling-enabling-kafka-signaling-channel" class="xref page">configured Kafka signaling topic</a> to stop an ad hoc incremental snapshot.</p>
</div>
<div class="paragraph">
<p>The key of the Kafka message must match the value of the <code>topic.prefix</code> connector configuration option.</p>
</div>
<div class="paragraph">
<p>The value of the message is a JSON object with <code>type</code> and <code>data</code> fields.</p>
</div>
<div class="paragraph">
<p>The signal type is <code>stop-snapshot</code>, and the <code>data</code> field must have the following fields:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Execute snapshot data fields</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Field</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>incremental</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of the snapshot to be executed.
Currently Debezium supports only the <code>incremental</code> type. <br>
See the next section for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>data-collections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N/A</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional array of comma-separated regular expressions that match the fully-qualified names of the tables an array of table names or regular expressions to match table names to remove from the snapshot.<br>
Specify table names by using the format <code>database.schema.table</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following example shows a typical <code>stop-snapshot</code> Kafka message:
:leveloffset: +1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">Key = `test_connector`

Value = `{"type":"stop-snapshot","data": {"data-collections": ["db1.schema1.table1", "db1.schema1.table2"], "type": "INCREMENTAL"}}`</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connector-custom-snapshot"><a class="anchor" href="#connector-custom-snapshot"></a>Custom snapshotter SPI</h3>
<div class="paragraph">
<p>For more advanced uses, you can fine-tune control of the snapshot by implementing one of the following interfaces:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>io.debezium.snapshot.spi.Snapshotter</code></dt>
<dd>
<p>Controls whether the connector takes a snapshot.</p>
</dd>
<dt class="hdlist1"><code>io.debezium.snapshot.spi.SnapshotQuery</code></dt>
<dd>
<p>Controls how data is queried during a snapshot.</p>
</dd>
<dt class="hdlist1"><code>io.debezium.snapshot.spi.SnapshotLock</code></dt>
<dd>
<p>Controls whether the connector locks tables when taking a snapshot.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">io.debezium.snapshot.spi.Snapshotter interface. All built-in snapshot modes implement this interface.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link Snapshotter} is used to determine the following details about the snapshot process:
 * &lt;p&gt;
 * - Whether a snapshot occurs. &lt;br&gt;
 * - Whether streaming continues during the snapshot. &lt;br&gt;
 * - Whether the snapshot includes schema (if supported). &lt;br&gt;
 * - Whether to snapshot data or schema following an error.
 * &lt;p&gt;
 * Although Debezium provides many default snapshot modes,
 * to provide more advanced functionality, such as partial snapshots,
 * you can customize implementation of the interface.
 * For more information, see the documentation.
 *
 *
 *
 */
@Incubating
public interface Snapshotter extends Configurable {

    /**
     * @return the name of the snapshotter.
     *
     *
     */
    String name();

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a data snapshot
     */
    boolean shouldSnapshotData(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @param offsetExists is {@code true} when the connector has an offset context (i.e. restarted)
     * @param snapshotInProgress is {@code true} when the connector is started, but a snapshot is already in progress
     *
     * @return {@code true} if the snapshotter should take a schema snapshot
     */
    boolean shouldSnapshotSchema(boolean offsetExists, boolean snapshotInProgress);

    /**
     * @return {@code true} if the snapshotter should stream after taking a snapshot
     */
    boolean shouldStream();

    /**
     * @return {@code true} whether the schema can be recovered if database schema history is corrupted.
     */
    boolean shouldSnapshotOnSchemaError();

    /**
     * @return {@code true} whether the snapshot should be re-executed when there is a gap in data stream.
     */
    boolean shouldSnapshotOnDataError();

    /**
     *
     * @return {@code true} if streaming should resume from the start of the snapshot
     * transaction, or {@code false} for when a connector resumes and takes a snapshot,
     * streaming should resume from where streaming previously left off.
     */
    default boolean shouldStreamEventsStartingFromSnapshot() {
        return true;
    }

    /**
     * Lifecycle hook called after the snapshot phase is successful.
     */
    default void snapshotCompleted() {
        // no operation
    }

    /**
     * Lifecycle hook called after the snapshot phase is aborted.
     */
    default void snapshotAborted() {
        // no operation
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">io.debezium.snapshot.spi.SnapshotQuery interface. All built-in snapshot query modes implement this interface.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link SnapshotQuery} is used to determine the query used during a data snapshot
 *
 *
 */
public interface SnapshotQuery extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Generate a valid query string for the specified table, or an empty {@link Optional}
     * to skip snapshotting this table (but that table will still be streamed from)
     *
     * @param tableId the table to generate a query for
     * @param snapshotSelectColumns the columns to be used in the snapshot select based on the column
     *                              include/exclude filters
     * @return a valid query string, or none to skip snapshotting this table
     */
    Optional&lt;String&gt; snapshotQuery(String tableId, List&lt;String&gt; snapshotSelectColumns);

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">io.debezium.snapshot.spi.SnapshotLock interface. All built-in snapshot lock modes implement this interface.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * {@link SnapshotLock} is used to determine the table lock mode used during schema snapshot
 *
 *
 */
public interface SnapshotLock extends Configurable, Service {

    /**
     * @return the name of the snapshot lock.
     *
     *
     */
    String name();

    /**
     * Returns a SQL statement for locking the given table during snapshotting, if required by the specific snapshotter
     * implementation.
     */
    Optional&lt;String&gt; tableLockingStatement(Duration lockTimeout, String tableId);

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-blocking-snapshots"><a class="anchor" href="#sqlserver-blocking-snapshots"></a>Blocking snapshots</h3>
<div class="paragraph">
<p>To provide more flexibility in managing snapshots, Debezium includes a supplementary ad hoc snapshot mechanism, known as a <em>blocking snapshot</em>.
Blocking snapshots rely on the Debezium mechanism for <a href="../configuration/signalling.html#sending-signals-to-a-debezium-connector" class="xref page">sending signals to a Debezium connector</a>.</p>
</div>
<div class="paragraph">
<p>A blocking snapshot behaves just like an <em>initial snapshot</em>, except that you can trigger it at run time.</p>
</div>
<div class="paragraph">
<p>You might want to run a blocking snapshot rather than use the standard initial snapshot process in the following situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You add a new table and you want to complete the snapshot while the connector is running.</p>
</li>
<li>
<p>You add a large table, and you want the snapshot to complete in less time than is possible with an incremental snapshot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Blocking snapshot process</div>
<p>When you run a blocking snapshot, Debezium stops streaming, and then initiates a snapshot of the specified table, following the same process that it uses during an initial snapshot.
After the snapshot completes, the streaming is resumed.</p>
</div>
<div class="paragraph">
<div class="title">Configure snapshot</div>
<p>You can set the following properties in the <code>data</code> component of a signal:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>data-collections: to specify which tables must be snapshot</p>
</li>
<li>
<p>additional-conditions: You can specify different filters for different table.<br></p>
<div class="ulist">
<ul>
<li>
<p>The <code>data-collection</code> property is the fully-qualified name of the table for which the filter will be applied.</p>
</li>
<li>
<p>The <code>filter</code> property will have the same value used in the  <code>snapshot.select.statement.overrides</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">  {"type": "blocking", "data-collections": ["schema1.table1", "schema1.table2"], "additional-conditions": [{"data-collection": "schema1.table1", "filter": "SELECT * FROM [schema1].[table1] WHERE column1 = 0 ORDER BY column2 DESC"}, {"data-collection": "schema1.table2", "filter": "SELECT * FROM [schema1].[table2] WHERE column2 &gt; 0"}]}</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Possible duplicates</div>
<p>A delay might exist between the time that you send the signal to trigger the snapshot, and the time when streaming stops and the snapshot starts.
As a result of this delay, after the snapshot completes, the connector might emit some event records that duplicate records captured by the snapshot.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reading_the_change_data_tables"><a class="anchor" href="#_reading_the_change_data_tables"></a>Reading the change data tables</h3>
<div class="paragraph">
<p>When the connector first starts, it takes a structural snapshot of the structure of the captured tables
and persists this information to its internal database schema history topic.
The connector then identifies a change table for each source table, and completes the following steps.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>For each change table, the connector read all of the changes that were created between the last stored maximum LSN and the current maximum LSN.</p>
</li>
<li>
<p>The connector sorts the changes that it reads in ascending order, based on the values of their commit LSN and change LSN.
This sorting order ensures that the changes are replayed by Debezium in the same order in which they occurred in the database.</p>
</li>
<li>
<p>The connector passes the commit and change LSNs as offsets to Kafka Connect.</p>
</li>
<li>
<p>The connector stores the maximum LSN and restarts the process from Step 1.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After a restart, the connector resumes processing from the last offset (commit and change LSNs) that it read.</p>
</div>
<div class="paragraph">
<p>The connector is able to detect whether CDC is enabled or disabled for included source tables and adjust its behavior.</p>
</div>
</div>
<div class="sect2">
<h3 id="_no_maximum_lsn_recorded_in_the_database"><a class="anchor" href="#_no_maximum_lsn_recorded_in_the_database"></a>No maximum LSN recorded in the database</h3>
<div class="paragraph">
<p>There may be situations when no maximum LSN is recorded in the database because:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SQL Server Agent is not running</p>
</li>
<li>
<p>No changes are recorded in the change table yet</p>
</li>
<li>
<p>Database has low activity and the cdc clean up job periodically clears entries from the cdc tables</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Out of these possibilities, since a running SQL Server Agent is a prerequisite, No 1. is a real problem (while No 2. and 3. are normal).</p>
</div>
<div class="paragraph">
<p>In order to mitigate this issue and differentiate between No 1. and the others, a check for the status of the SQL Server Agent is done through the following query <code>"SELECT CASE WHEN dss.[status]=4 THEN 1 ELSE 0 END AS isRunning FROM [#db].sys.dm_server_services dss WHERE dss.[servicename] LIKE N&#8217;SQL Server Agent (%';"</code>.
If the SQL Server Agent is not running, an ERROR is written in the log: "No maximum LSN recorded in the database; SQL Server Agent is not running".</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The SQL Server Agent running status query requires <code>VIEW SERVER STATE</code> server permission.
If you don&#8217;t want to grant this permission to the configured user, you can choose to configure your own query through the <code>database.sqlserver.agent.status.query</code> property.
You can define a function which returns true or 1 if SQL Server Agent is running (false or 0 otherwise) and safely use High-Level permissions without granting them as explained
here <a href="https://dba.stackexchange.com/questions/62230/what-minimum-permissions-do-i-need-to-provide-to-a-user-so-that-it-can-check-the/103275#103275">What minimum permissions do I need to provide to a user so that it can check the status of SQL Server Agent Service?</a>
or here <a href="https://sqlquantumleap.com/2018/02/15/safely-and-easily-use-high-level-permissions-without-granting-them-to-anyone-server-level/">Safely and Easily Use High-Level Permissions Without Granting Them to Anyone: Server-level</a>.
The configuration of the query property would look like: <code>database.sqlserver.agent.status.query=SELECT [#db].func_is_sql_server_agent_running()</code> - you need to use <code>[#db]</code> as placeholder for the database name.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_limitations"><a class="anchor" href="#_limitations"></a>Limitations</h3>
<div class="paragraph">
<p>SQL Server specifically requires the base object to be a table in order to create a change capture instance.
As consequence, capturing changes from indexed views (aka. materialized views) is not supported by SQL Server and hence Debezium SQL Server connector.</p>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-topic-names"><a class="anchor" href="#sqlserver-topic-names"></a>Topic names</h3>
<div class="paragraph">
<p>By default, the SQL Server connector writes events for all <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations that occur in a table to a single Apache Kafka topic that is specific to that table.
The connector uses the following convention to name change event topics:
<code><em>&lt;topicPrefix&gt;</em>.<em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em></code></p>
</div>
<div class="paragraph">
<p>The following list provides definitions for the components of the default name:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>topicPrefix</em></dt>
<dd>
<p>The logical name of the server, as specified by the <a href="#sqlserver-property-topic-prefix"><code>topic.prefix</code></a> configuration property.</p>
</dd>
<dt class="hdlist1"><em>schemaName</em></dt>
<dd>
<p>The name of the database schema in which the change event occurred.</p>
</dd>
<dt class="hdlist1"><em>tableName</em></dt>
<dd>
<p>The name of the database table in which the change event occurred.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, if <code>fulfillment</code> is the logical server name, and <code>dbo</code> is the schema name, and the database contains tables with the names <code>products</code>, <code>products_on_hand</code>, <code>customers</code>, and <code>orders</code>,
the connector would stream change event records to the following Kafka topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fulfillment.testDB.dbo.products</code></p>
</li>
<li>
<p><code>fulfillment.testDB.dbo.products_on_hand</code></p>
</li>
<li>
<p><code>fulfillment.testDB.dbo.customers</code></p>
</li>
<li>
<p><code>fulfillment.testDB.dbo.orders</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The connector applies similar naming conventions to label its internal database schema history topics, <a href="#about-the-debezium-sqlserver-connector-schema-change-topic">schema change topics</a>, and <a href="#sqlserver-transaction-metadata">transaction metadata topics</a>.</p>
</div>
<div class="paragraph">
<p>If the default topic name do not meet your requirements, you can configure custom topic names.
To configure custom topic names, you specify regular expressions in the logical topic routing SMT.
For more information about using the logical topic routing SMT to customize topic naming, see <a href="../transformations/topic-routing.html#topic-routing" class="xref page">Topic routing</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-schema-history-topic"><a class="anchor" href="#sqlserver-schema-history-topic"></a>Schema history topic</h3>
<div class="paragraph">
<p>When a database client queries a database, the client uses the database’s current schema.
However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded.
Also, a connector cannot necessarily apply the current schema to every event.
If an event is relatively old, it&#8217;s possible that it was recorded before the current schema was applied.</p>
</div>
<div class="paragraph">
<p>To ensure correct processing of change events that occur after a schema change, the Debezium SQL Server connector stores a snapshot of the new schema based on the structure in the SQL Server change tables, which mirror the structure of their associated data tables.
The connector stores the table schema information, together with the LSN of operations the result in schema changes, in the database schema history Kafka topic.
The connector uses the stored schema representation to produce change events that correctly mirror the structure of tables at the time of each insert, update, or delete operation.</p>
</div>
<div class="paragraph">
<p>When the connector restarts after either a crash or a graceful stop, it resumes reading entries in the SQL Server CDC tables from the last position that it read.
Based on the schema information that the connector reads from the database schema history topic, the connector applies the table structures that existed at the position where the connector restarts.</p>
</div>
<div class="paragraph">
<p>If you update the schema of a Db2 table that is in capture mode, it&#8217;s important that you also update the schema of the corresponding change table.
You must be a SQL Server database administrator with elevated privileges to update database schema.
For more information about updating SQL Server database schema in Debezium environmenbts, see <a href="#sqlserver-schema-evolution">Database schema evolution</a>.</p>
</div>
<div class="paragraph">
<p>The database schema history topic is for internal connector use only.
Optionally, the connector can also <a href="#about-the-debezium-sqlserver-connector-schema-change-topic">emit schema change events to a different topic that is intended for consumer applications</a>.</p>
</div>
<div class="ulist">
<div class="title">Additional resources</div>
<ul>
<li>
<p><a href="#sqlserver-topic-names">Default names for topics</a> that receive Debezium event records.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="about-the-debezium-sqlserver-connector-schema-change-topic"><a class="anchor" href="#about-the-debezium-sqlserver-connector-schema-change-topic"></a>Schema change topic</h3>
<div class="paragraph">
<p>For each table for which CDC is enabled, the Debezium SQL Server connector stores a history of the schema change events that are applied to tables in the database.
The connector writes schema change events to a Kafka topic named <code><em>&lt;topicPrefix&gt;</em></code>, where <code><em>topicPrefix</em></code> is the logical server name that is specified in the <a href="#sqlserver-property-topic-prefix"><code>topic.prefix</code></a> configuration property.</p>
</div>
<div class="paragraph">
<p>Messages that the connector sends to the schema change topic contain a payload, and, optionally, also contain the schema of the change event message.</p>
</div>
<div class="paragraph">
<p>The schema for the schema change event has the following elements:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>name</code></dt>
<dd>
<p>The name of the schema change event message.</p>
</dd>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>The type of the change event message.</p>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>The version of the schema. The version is an integer that is incremented each time the schema is changed.</p>
</dd>
<dt class="hdlist1"><code>fields</code></dt>
<dd>
<p>The fields that are included in the change event message.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<div class="title">Example: Schema of the SQL Server connector schema change topic</div>
<p>The following example shows a typical schema in JSON format.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.sqlserver.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "inventory"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The payload of a schema change event message includes the following elements:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>databaseName</code></dt>
<dd>
<p>The name of the database to which the statements are applied.
The value of <code>databaseName</code> serves as the message key.</p>
</dd>
<dt class="hdlist1"><code>tableChanges</code></dt>
<dd>
<p>A structured representation of the entire table schema after the schema change.
The <code>tableChanges</code> field contains an array that includes entries for each column of the table.
Because the structured representation presents data in JSON or Avro format, consumers can easily read messages without first processing them through a DDL parser.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the connector is configured to capture a table, it stores the history of the table&#8217;s schema changes not only in the schema change topic, but also in an internal database schema history topic.
The internal database schema history topic is for connector use only and it is not intended for direct use by consuming applications.
Ensure that applications that require notifications about schema changes consume that information only from the schema change topic.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The format of the messages that a connector emits to its schema change topic is in an incubating state and can change without notice.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Debezium emits a message to the schema change topic when the following events occur:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You enable CDC for a table.</p>
</li>
<li>
<p>You disable CDC for a table.</p>
</li>
<li>
<p>You alter the structure of a table for which CDC is enabled by following the <a href="#sqlserver-schema-evolution">schema evolution procedure</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Example: Message emitted to the SQL Server connector schema change topic</div>
<p>The following example shows a message in the schema change topic.
The message contains a logical representation of the table schema.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": {
  ...
  },
  "payload": {
    "source": {
      "version": "2.7.2.Final",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 0,
      "snapshot": "true",
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": null,
      "commit_lsn": "00000025:00000d98:00a2",
      "event_serial_no": null
    },
    "ts_ms": 1588252618953, <i class="conum" data-value="1"></i><b>(1)</b>
    "databaseName": "testDB", <i class="conum" data-value="2"></i><b>(2)</b>
    "schemaName": "dbo",
    "ddl": null, <i class="conum" data-value="3"></i><b>(3)</b>
    "tableChanges": [ <i class="conum" data-value="4"></i><b>(4)</b>
      {
        "type": "CREATE", <i class="conum" data-value="5"></i><b>(5)</b>
        "id": "\"testDB\".\"dbo\".\"customers\"", <i class="conum" data-value="6"></i><b>(6)</b>
        "table": { <i class="conum" data-value="7"></i><b>(7)</b>
          "defaultCharsetName": null,
          "primaryKeyColumnNames": [ <i class="conum" data-value="8"></i><b>(8)</b>
            "id"
          ],
          "columns": [ <i class="conum" data-value="9"></i><b>(9)</b>
            {
              "name": "id",
              "jdbcType": 4,
              "nativeType": null,
              "typeName": "int identity",
              "typeExpression": "int identity",
              "charsetName": null,
              "length": 10,
              "scale": 0,
              "position": 1,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "first_name",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 2,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "last_name",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 3,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            },
            {
              "name": "email",
              "jdbcType": 12,
              "nativeType": null,
              "typeName": "varchar",
              "typeExpression": "varchar",
              "charsetName": null,
              "length": 255,
              "scale": null,
              "position": 4,
              "optional": false,
              "autoIncremented": false,
              "generated": false
            }
          ],
          "attributes": [ <i class="conum" data-value="10"></i><b>(10)</b>
            {
              "customAttribute": "attributeValue"
            }
          ]
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Descriptions of fields in messages emitted to the schema change topic</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 40%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ts_ms</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.</p>
<p class="tableblock">In the source object, ts_ms indicates the time that the change was made in the database. By comparing the value for payload.source.ts_ms with the value for payload.ts_ms, you can determine the lag between the source database update and Debezium.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>databaseName</code><br>
<code>schemaName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identifies the database and the schema that contain the change.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ddl</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Always <code>null</code> for the SQL Server connector.
For other connectors, this field contains the DDL responsible for the schema change.
This DDL is not available to SQL Server connectors.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tableChanges</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of one or more items that contain the schema changes generated by a DDL command.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Describes the kind of change. The value is one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> - table created</p>
</li>
<li>
<p><code>ALTER</code> - table modified</p>
</li>
<li>
<p><code>DROP</code> - table deleted</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full identifier of the table that was created, altered, or dropped.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>table</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Represents table metadata after the applied change.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>primaryKeyColumnNames</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of columns that compose the table&#8217;s primary key.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>columns</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Metadata for each column in the changed table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom attribute metadata for each table change.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In messages that the connector sends to the schema change topic, the key is the name of the database that contains the schema change.
In the following example, the <code>payload</code> field contains the key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": {
    "type": "struct",
    "fields": [
      {
        "type": "string",
        "optional": false,
        "field": "databaseName"
      }
    ],
    "optional": false,
    "name": "io.debezium.connector.sqlserver.SchemaChangeKey",
    "version": 1
  },
  "payload": {
    "databaseName": "testDB"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_data_change_events"><a class="anchor" href="#_data_change_events"></a>Data change events</h3>
<div class="paragraph">
<p>The Debezium SQL Server connector generates a data change event for each row-level <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed.</p>
</div>
<div class="paragraph">
<p>Debezium and Kafka Connect are designed around <em>continuous streams of event messages</em>. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained.</p>
</div>
<div class="paragraph">
<p>The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A <code>schema</code> field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converter and you configure it to produce all four basic change event parts, change events have this structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
 "schema": { <i class="conum" data-value="1"></i><b>(1)</b>
   ...
  },
 "payload": { <i class="conum" data-value="2"></i><b>(2)</b>
   ...
 },
 "schema": { <i class="conum" data-value="3"></i><b>(3)</b>
   ...
 },
 "payload": { <i class="conum" data-value="4"></i><b>(4)</b>
   ...
 },
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Overview of change event basic content</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The first <code>schema</code> field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key&#8217;s <code>payload</code> portion. In other words, the first <code>schema</code> field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed.<br>
<br>
It is possible to override the table&#8217;s primary key by setting the <a href="#sqlserver-property-message-key-columns"><code>message.key.columns</code> connector configuration property</a>. In this case, the first schema field describes the structure of the key identified by that property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The first <code>payload</code> field is part of the event key. It has the structure described by the previous <code>schema</code> field and it contains the key for the row that was changed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The second <code>schema</code> field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value&#8217;s <code>payload</code> portion. In other words, the second <code>schema</code> describes the structure of the row that was changed. Typically, this schema contains nested schemas.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The second <code>payload</code> field is part of the event value. It has the structure described by the previous <code>schema</code> field and it contains the actual data for the row that was changed.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>By default, the connector streams change event records to topics with names that are the same as the event&#8217;s originating table.
For more information, see <a href="#sqlserver-topic-names">topic names</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The SQL Server connector ensures that all Kafka Connect schema names adhere to the <a href="http://avro.apache.org/docs/current/spec.html#names">Avro schema name format</a>. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or _. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or \_. If there is an invalid character it is replaced with an underscore character.</p>
</div>
<div class="paragraph">
<p>This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-change-event-keys"><a class="anchor" href="#sqlserver-change-event-keys"></a>Change event keys</h4>
<div class="paragraph">
<p>A change event&#8217;s key contains the schema for the changed table&#8217;s key and the changed row&#8217;s actual key. Both the schema and its corresponding payload contain a field for each column in the changed table&#8217;s primary key (or unique key constraint) at the time the connector created the event.</p>
</div>
<div class="paragraph">
<p>Consider the following <code>customers</code> table, which is followed by an example of a change event key for this table.</p>
</div>
<div class="listingblock">
<div class="title">Example table</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE customers (
  id INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE
);</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Example change event key</div>
<p>Every change event that captures a change to the <code>customers</code> table has the same event key schema. For as long as the <code>customers</code> table has the previous definition, every change event that captures a change to the <code>customers</code> table has the following key structure, which in JSON, looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "schema": { <i class="conum" data-value="1"></i><b>(1)</b>
        "type": "struct",
        "fields": [ <i class="conum" data-value="2"></i><b>(2)</b>
            {
                "type": "int32",
                "optional": false,
                "field": "id"
            }
        ],
        "optional": false, <i class="conum" data-value="3"></i><b>(3)</b>
        "name": "server1.testDB.dbo.customers.Key" <i class="conum" data-value="4"></i><b>(4)</b>
    },
    "payload": { <i class="conum" data-value="5"></i><b>(5)</b>
        "id": 1004
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Description of change event key</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The schema portion of the key specifies a Kafka Connect schema that describes what is in the key&#8217;s <code>payload</code> portion.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fields</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies each field that is expected in the <code>payload</code>, including each field&#8217;s name, type, and whether it is required. In this example, there is one required field named <code>id</code> of type <code>int32</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>optional</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates whether the event key must contain a value in its <code>payload</code> field. In this example, a value in the key&#8217;s payload is required. A value in the key&#8217;s payload field is optional when a table does not have a primary key.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>server1.dbo.testDB.customers.Key</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Name of the schema that defines the structure of the key&#8217;s payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format <em>connector-name</em>.<em>database-schema-name</em>.<em>table-name</em>.<code>Key</code>. In this example:<br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>server1</code> is the name of the connector that generated this event.<br></p>
</li>
<li>
<p><code>dbo</code> is the database schema for the table that was changed.<br></p>
</li>
<li>
<p><code>customers</code> is the table that was updated.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contains the key for the row for which this change event was generated. In this example, the key, contains a single <code>id</code> field whose value is <code>1004</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When Debezium emits a change event record, it sets the message key for each record to the name of the primary key or unique key column of the source table.
Debezium must be able to read these columns to function properly.
If you set the <a href="#sqlserver-property-column-include-list"><code>column.include.list</code></a> or <a href="#sqlserver-property-column-exclude-list"><code>column.exclude.list</code></a> properties in the connector configuration,
be sure that your settings permit the connector to capture the required primary key or unique key columns.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the table does not have a primary or unique key, then the change event&#8217;s key is null. This makes sense since the rows in a table without a primary or unique key constraint cannot be uniquely identified.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="sqlserver-change-event-values"><a class="anchor" href="#sqlserver-change-event-values"></a>Change event values</h4>
<div class="paragraph">
<p>The value in a change event is a bit more complicated than the key. Like the key, the value has a <code>schema</code> section and a <code>payload</code> section. The <code>schema</code> section contains the schema that describes the <code>Envelope</code> structure of the <code>payload</code> section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure.</p>
</div>
<div class="paragraph">
<p>Consider the same sample table that was used to show an example of a change event key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE customers (
  id INTEGER IDENTITY(1001,1) NOT NULL PRIMARY KEY,
  first_name VARCHAR(255) NOT NULL,
  last_name VARCHAR(255) NOT NULL,
  email VARCHAR(255) NOT NULL UNIQUE
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value portion of a change event for a change to this table is described for each event type.</p>
</div>
<div class="sect4">
<h5 id="sqlserver-create-events"><a class="anchor" href="#sqlserver-create-events"></a><em>create</em> events</h5>
<div class="paragraph">
<p>The following example shows the value portion of a change event that the connector generates for an operation that creates data in the <code>customers</code> table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": { <i class="conum" data-value="1"></i><b>(1)</b>
    "type": "struct",
    "fields": [
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "server1.dbo.testDB.customers.Value", <i class="conum" data-value="2"></i><b>(2)</b>
        "field": "before"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "int32",
            "optional": false,
            "field": "id"
          },
          {
            "type": "string",
            "optional": false,
            "field": "first_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "last_name"
          },
          {
            "type": "string",
            "optional": false,
            "field": "email"
          }
        ],
        "optional": true,
        "name": "server1.dbo.testDB.customers.Value",
        "field": "after"
      },
      {
        "type": "struct",
        "fields": [
          {
            "type": "string",
            "optional": false,
            "field": "version"
          },
          {
            "type": "string",
            "optional": false,
            "field": "connector"
          },
          {
            "type": "string",
            "optional": false,
            "field": "name"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ms"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_us"
          },
          {
            "type": "int64",
            "optional": false,
            "field": "ts_ns"
          },
          {
            "type": "boolean",
            "optional": true,
            "default": false,
            "field": "snapshot"
          },
          {
            "type": "string",
            "optional": false,
            "field": "db"
          },
          {
            "type": "string",
            "optional": false,
            "field": "schema"
          },
          {
            "type": "string",
            "optional": false,
            "field": "table"
          },
          {
            "type": "string",
            "optional": true,
            "field": "change_lsn"
          },
          {
            "type": "string",
            "optional": true,
            "field": "commit_lsn"
          },
          {
            "type": "int64",
            "optional": true,
            "field": "event_serial_no"
          }
        ],
        "optional": false,
        "name": "io.debezium.connector.sqlserver.Source", <i class="conum" data-value="3"></i><b>(3)</b>
        "field": "source"
      },
      {
        "type": "string",
        "optional": false,
        "field": "op"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ms"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_us"
      },
      {
        "type": "int64",
        "optional": true,
        "field": "ts_ns"
      }
    ],
    "optional": false,
    "name": "server1.dbo.testDB.customers.Envelope" <i class="conum" data-value="4"></i><b>(4)</b>
  },
  "payload": { <i class="conum" data-value="5"></i><b>(5)</b>
    "before": null, <i class="conum" data-value="6"></i><b>(6)</b>
    "after": { <i class="conum" data-value="7"></i><b>(7)</b>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "john.doe@example.org"
    },
    "source": { <i class="conum" data-value="8"></i><b>(8)</b>
      "version": "2.7.2.Final",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559729468470,
      "ts_us": 1559729468470000,
      "ts_ns": 1559729468470000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000758:0003",
      "commit_lsn": "00000027:00000758:0005",
      "event_serial_no": "1"
    },
    "op": "c", <i class="conum" data-value="9"></i><b>(9)</b>
    "ts_ms": 1559729471739, <i class="conum" data-value="10"></i><b>(10)</b>
    "ts_ms": 1559729471739876, <i class="conum" data-value="10"></i><b>(10)</b>
    "ts_ms": 1559729471739876149 <i class="conum" data-value="10"></i><b>(10)</b>
  }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Descriptions of <em>create</em> event value fields</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>schema</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The value&#8217;s schema, which describes the structure of the value&#8217;s payload. A change event&#8217;s value schema is the same in every change event that the connector generates for a particular table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>In the <code>schema</code> section, each <code>name</code> field specifies the schema for a field in the value&#8217;s payload.<br>
<br>
<code>server1.dbo.testDB.customers.Value</code> is the schema for the payload&#8217;s <code>before</code> and <code>after</code> fields. This schema is specific to the <code>customers</code> table.<br>
<br>
 Names of schemas for <code>before</code> and <code>after</code> fields are of the form <code><em>logicalName</em>.<em>database-schemaName</em>.<em>tableName</em>.Value</code>, which ensures that the schema name is unique in the database.
 This means that when using the <a href="../configuration/avro.html#avro-serialization" class="xref page">Avro converter</a>, the resulting Avro schema for each table in each logical source has its own evolution and history.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.connector.sqlserver.Source</code> is the schema for the payload&#8217;s <code>source</code> field. This schema is specific to the SQL Server connector. The connector uses it for all events that it generates.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>server1.dbo.testDB.customers.Envelope</code> is the schema for the overall structure of the payload, where <code>server1</code> is the connector name, <code>dbo</code> is the database schema name, and <code>customers</code> is the table.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>payload</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The value&#8217;s actual data. This is the information that the change event is providing.<br>
<br>
It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.
However, by using the <a href="../configuration/avro.html#avro-serialization" class="xref page">Avro converter</a>, you can significantly decrease the size of the messages that the connector streams to Kafka topics.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional field that specifies the state of the row before the event occurred. When the <code>op</code> field is <code>c</code> for create, as it is in this example, the <code>before</code> field is <code>null</code> since this change event is for new content.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>after</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional field that specifies the state of the row after the event occurred. In this example, the <code>after</code> field contains the values of the new row&#8217;s <code>id</code>, <code>first_name</code>, <code>last_name</code>, and <code>email</code> columns.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>source</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debezium version</p>
</li>
<li>
<p>Connector type and name</p>
</li>
<li>
<p>Database and schema names</p>
</li>
<li>
<p>Timestamp for when the change was made in the database</p>
</li>
<li>
<p>If the event was part of a snapshot</p>
</li>
<li>
<p>Name of the table that contains the new row</p>
</li>
<li>
<p>Server log offsets</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, <code>c</code> indicates that the operation created a row. Valid values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>c</code> = create</p>
</li>
<li>
<p><code>u</code> = update</p>
</li>
<li>
<p><code>d</code> = delete</p>
</li>
<li>
<p><code>r</code> = read (applies to only snapshots)</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ts_ms</code>, <code>ts_us</code>, <code>ts_ns</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task.<br>
<br>
In the <code>source</code> object, <code>ts_ms</code> indicates the time when a change was committed in the database.
By comparing the value for <code>payload.source.ts_ms</code> with the value for <code>payload.ts_ms</code>, you can determine the lag between the source database update and Debezium.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="sqlserver-update-events"><a class="anchor" href="#sqlserver-update-events"></a><em>update</em> events</h5>
<div class="paragraph">
<p>The value of a change event for an update in the sample <code>customers</code> table has the same schema as a <em>create</em> event for that table. Likewise, the event value&#8217;s payload has the same structure. However, the event value payload contains different values in an <em>update</em> event. Here is an example of a change event value in an event that the connector generates for an update in the <code>customers</code> table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": { ... },
  "payload": {
    "before": { <i class="conum" data-value="1"></i><b>(1)</b>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "john.doe@example.org"
    },
    "after": { <i class="conum" data-value="2"></i><b>(2)</b>
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "noreply@example.org"
    },
    "source": { <i class="conum" data-value="3"></i><b>(3)</b>
      "version": "2.7.2.Final",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559729995937,
      "ts_us": 1559729995937000,
      "ts_ns": 1559729995937000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000ac0:0002",
      "commit_lsn": "00000027:00000ac0:0007",
      "event_serial_no": "2"
    },
    "op": "u", <i class="conum" data-value="4"></i><b>(4)</b>
    "ts_ms": 1559729998706,  <i class="conum" data-value="5"></i><b>(5)</b>
    "ts_us": 1559729998706318,  <i class="conum" data-value="5"></i><b>(5)</b>
    "ts_ns": 1559729998706318547  <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Descriptions of <em>update</em> event value fields</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional field that specifies the state of the row before the event occurred. In an <em>update</em> event value, the <code>before</code> field contains a field for each table column and the value that was in that column before the database commit. In this example, the <code>email</code> value is <code>john.doe@example.org.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>after</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional field that specifies the state of the row after the event occurred. You can compare the <code>before</code> and <code>after</code> structures to determine what the update to this row was. In the example, the <code>email</code> value is now <code>noreply@example.org</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>source</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory field that describes the source metadata for the event. The <code>source</code> field structure has the same fields as in a <em>create</em> event, but some values are different, for example, the sample <em>update</em> event has a different offset. The source metadata includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debezium version</p>
</li>
<li>
<p>Connector type and name</p>
</li>
<li>
<p>Database and schema names</p>
</li>
<li>
<p>Timestamp for when the change was made in the database</p>
</li>
<li>
<p>If the event was part of a snapshot</p>
</li>
<li>
<p>Name of the table that contains the new row</p>
</li>
<li>
<p>Server log offsets</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>event_serial_no</code> field differentiates events that have the same commit and change LSN. Typical situations for when this field has a value other than <code>1</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>update</em> events have the value set to <code>2</code> because the update generates two events in the CDC change table of SQL Server (<a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-tables/cdc-capture-instance-ct-transact-sql?view=sql-server-2017">see the source documentation for details</a>). The first event contains the old values and the second contains contains new values. The connector uses values in the first event to create the second event. The connector drops the first event.</p>
</li>
<li>
<p>When a primary key is updated SQL Server emits two events. A <em>delete</em> event for the removal of the record with the old primary key value and a <em>create</em> event for the addition of the record with the new primary key.
Both operations share the same commit and change LSN and their event numbers are <code>1</code> and <code>2</code>, respectively.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory string that describes the type of operation. In an <em>update</em> event value, the <code>op</code> field value is <code>u</code>, signifying that this row changed because of an update.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ts_ms</code>, <code>ts_us</code>, <code>ts_ns</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task.<br>
<br>
In the <code>source</code> object, <code>ts_ms</code> indicates the time when the change was committed to the database.
By comparing the value for <code>payload.source.ts_ms</code> with the value for <code>payload.ts_ms</code>, you can determine the lag between the source database update and Debezium.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Updating the columns for a row&#8217;s primary/unique key changes the value of the row&#8217;s key. When a key changes, Debezium outputs <em>three</em> events: a <em>delete</em> event and a <a href="#sqlserver-tombstone-events">tombstone event</a> with the old key for the row, followed by a <em>create</em> event with the new key for the row.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="sqlserver-delete-events"><a class="anchor" href="#sqlserver-delete-events"></a><em>delete</em> events</h5>
<div class="paragraph">
<p>The value in a <em>delete</em> change event has the same <code>schema</code> portion as <em>create</em> and <em>update</em> events for the same table. The <code>payload</code> portion in a <em>delete</em> event for the sample <code>customers</code> table looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "schema": { ... },
  },
  "payload": {
    "before": { &lt;&gt;
      "id": 1005,
      "first_name": "john",
      "last_name": "doe",
      "email": "noreply@example.org"
    },
    "after": null, <i class="conum" data-value="2"></i><b>(2)</b>
    "source": { <i class="conum" data-value="3"></i><b>(3)</b>
      "version": "2.7.2.Final",
      "connector": "sqlserver",
      "name": "server1",
      "ts_ms": 1559730445243,
      "ts_us": 1559730445243000,
      "ts_ns": 1559730445243000000,
      "snapshot": false,
      "db": "testDB",
      "schema": "dbo",
      "table": "customers",
      "change_lsn": "00000027:00000db0:0005",
      "commit_lsn": "00000027:00000db0:0007",
      "event_serial_no": "1"
    },
    "op": "d", <i class="conum" data-value="4"></i><b>(4)</b>
    "ts_ms": 1559730450205, <i class="conum" data-value="5"></i><b>(5)</b>
    "ts_us": 1559730450205387, <i class="conum" data-value="5"></i><b>(5)</b>
    "ts_ns": 1559730450205387492  <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Descriptions of <em>delete</em> event value fields</caption>
<colgroup>
<col style="width: 10%;">
<col style="width: 20%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Item</th>
<th class="tableblock halign-left valign-top">Field name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional field that specifies the state of the row before the event occurred. In a <em>delete</em> event value, the <code>before</code> field contains the values that were in the row before it was deleted with the database commit.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>after</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional field that specifies the state of the row after the event occurred. In a <em>delete</em> event value, the <code>after</code> field is <code>null</code>, signifying that the row no longer exists.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>source</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory field that describes the source metadata for the event. In a <em>delete</em> event value, the <code>source</code> field structure is the same as for <em>create</em> and <em>update</em> events for the same table. Many <code>source</code> field values are also the same. In a <em>delete</em> event value, the <code>ts_ms</code> and <code>pos</code> field values, as well as other values, might have changed. But the <code>source</code> field in a <em>delete</em> event value provides the same metadata:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Debezium version</p>
</li>
<li>
<p>Connector type and name</p>
</li>
<li>
<p>Database and schema names</p>
</li>
<li>
<p>Timestamp for when the change was made in the database</p>
</li>
<li>
<p>If the event was part of a snapshot</p>
</li>
<li>
<p>Name of the table that contains the new row</p>
</li>
<li>
<p>Server log offsets</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>op</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mandatory string that describes the type of operation. The <code>op</code> field value is <code>d</code>, signifying that this row was deleted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ts_ms</code>, <code>ts_us</code>, <code>ts_ns</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Optional field that displays the time at which the connector processed the event.
In the event message envelope, the time is based on the system clock in the JVM running the Kafka Connect task.<br>
<br>
In the <code>source</code> object, <code>ts_ms</code> indicates the time that the change was made in the database.
By comparing the value for <code>payload.source.ts_ms</code> with the value for <code>payload.ts_ms</code>, you can determine the lag between the source database update and Debezium.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>SQL Server connector events are designed to work with <a href="https://kafka.apache.org/documentation/#compaction">Kafka log compaction</a>. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.</p>
</div>
<div id="sqlserver-tombstone-events" class="paragraph">
<div class="title">Tombstone events</div>
<p>When a row is deleted, the <em>delete</em> event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be <code>null</code>. To make this possible, after Debezium’s SQL Server connector emits a <em>delete</em> event, the connector emits a special tombstone event that has the same key but a <code>null</code> value.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-transaction-metadata"><a class="anchor" href="#sqlserver-transaction-metadata"></a>Transaction metadata</h3>
<div class="paragraph">
<p>Debezium can generate events that represent transaction boundaries and that enrich data change event messages.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Limits on when Debezium receives transaction metadata</div>
<div class="paragraph">
<p>Debezium registers and receives metadata only for transactions that occur after you deploy the connector.
Metadata for transactions that occur before you deploy the connector is not available.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Database transactions are represented by a statement block that is enclosed between the <code>BEGIN</code> and <code>END</code> keywords.
Debezium generates transaction boundary events for the <code>BEGIN</code> and <code>END</code> delimiters in every transaction.
Transaction boundary events contain the following fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>status</code></dt>
<dd>
<p><code>BEGIN</code> or <code>END</code>.</p>
</dd>
<dt class="hdlist1"><code>id</code></dt>
<dd>
<p>String representation of the unique transaction identifier.</p>
</dd>
<dt class="hdlist1"><code>ts_ms</code></dt>
<dd>
<p>The time of a transaction boundary event (<code>BEGIN</code> or <code>END</code> event) at the data source.
If the data source does not provide Debezium with the event time, then the field instead represents the time at which Debezium processes the event.</p>
</dd>
<dt class="hdlist1"><code>event_count</code> (for <code>END</code> events)</dt>
<dd>
<p>Total number of events emmitted by the transaction.</p>
</dd>
<dt class="hdlist1"><code>data_collections</code> (for <code>END</code> events)</dt>
<dd>
<p>An array of pairs of <code>data_collection</code> and <code>event_count</code> elements that indicates the number of events that the connector emits for changes that originate from a data collection.</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is no way for Debezium to reliably identify when a transaction has ended.
The transaction <code>END</code> marker is thus emitted only after the first event of another transaction arrives.
This can lead to the delayed delivery of <code>END</code> marker in case of a low-traffic system.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows a typical transaction boundary message:</p>
</div>
<div class="listingblock">
<div class="title">Example: SQL Server connector transaction boundary event</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "status": "BEGIN",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577125,
  "event_count": null,
  "data_collections": null
}

{
  "status": "END",
  "id": "00000025:00000d08:0025",
  "ts_ms": 1486500577691,
  "event_count": 2,
  "data_collections": [
    {
      "data_collection": "testDB.dbo.testDB.tablea",
      "event_count": 1
    },
    {
      "data_collection": "testDB.dbo.testDB.tableb",
      "event_count": 1
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unless overridden via the <a href="#sqlserver-property-topic-transaction"><code>topic.transaction</code></a> option,
transaction events are written to the topic named <a href="#sqlserver-property-topic-prefix"><code><em>&lt;topic.prefix&gt;</em></code></a><code>.transaction</code>.</p>
</div>
<div class="sect3">
<h4 id="_change_data_event_enrichment"><a class="anchor" href="#_change_data_event_enrichment"></a>Change data event enrichment</h4>
<div class="paragraph">
<p>When transaction metadata is enabled, the data message <code>Envelope</code> is enriched with a new <code>transaction</code> field.
This field provides information about every event in the form of a composite of fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>id</code></dt>
<dd>
<p>String representation of unique transaction identifier</p>
</dd>
<dt class="hdlist1"><code>total_order</code></dt>
<dd>
<p>The absolute position of the event among all events generated by the transaction</p>
</dd>
<dt class="hdlist1"><code>data_collection_order</code></dt>
<dd>
<p>The per-data collection position of the event among all events that were emitted by the transaction</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The following example shows what a typical message looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "before": null,
  "after": {
    "pk": "2",
    "aa": "1"
  },
  "source": {
...
  },
  "op": "c",
  "ts_ms": "1580390884335",
  "ts_us": "1580390884335172",
  "ts_ns": "1580390884335172574",
  "transaction": {
    "id": "00000025:00000d08:0025",
    "total_order": "1",
    "data_collection_order": "1"
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-data-types"><a class="anchor" href="#sqlserver-data-types"></a>Data type mappings</h3>
<div class="paragraph">
<p>The Debezium SQL Server connector represents changes to table row data by producing events that are structured like the table in which the row exists.
Each event contains fields to represent the column values for the row.
The way in which an event represents the column values for an operation depends on the SQL data type of the column.
In the event, the connector maps the fields for each SQL Server data type to both a <em>literal type</em> and a <em>semantic type</em>.</p>
</div>
<div class="paragraph">
<p>The connector can map SQL Server data types to both <em>literal</em> and <em>semantic</em> types.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Literal type</dt>
<dd>
<p>Describes how the value is literally represented by using Kafka Connect schema types, namely <code>INT8</code>, <code>INT16</code>, <code>INT32</code>, <code>INT64</code>, <code>FLOAT32</code>, <code>FLOAT64</code>, <code>BOOLEAN</code>, <code>STRING</code>, <code>BYTES</code>, <code>ARRAY</code>, <code>MAP</code>, and <code>STRUCT</code>.</p>
</dd>
<dt class="hdlist1">Semantic type</dt>
<dd>
<p>Describes how the Kafka Connect schema captures the <em>meaning</em> of the field using the name of the Kafka Connect schema for the field.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If the default data type conversions do not meet your needs, you can <a href="../development/converters.html#custom-converters" class="xref page">create a custom converter</a> for the connector.</p>
</div>
<div class="sect3">
<h4 id="sql-server-basic-values"><a class="anchor" href="#sql-server-basic-values"></a>Basic types</h4>
<div class="paragraph">
<p>The following table shows how the connector maps basic SQL Server data types.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Data type mappings used by the SQL Server connector</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server data type</th>
<th class="tableblock halign-left valign-top">Literal type (schema type)</th>
<th class="tableblock halign-left valign-top">Semantic type (schema name) and Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BIT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BOOLEAN</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TINYINT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT16</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLINT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT16</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT32</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BIGINT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>REAL</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT32</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT[(N)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>CHAR[(N)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>VARCHAR[(N)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TEXT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NCHAR[(N)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NVARCHAR[(N)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NTEXT</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>n/a</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>XML</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.data.Xml</code><br>
<br>
Contains the string representation of an XML document</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIMEOFFSET[(P)]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.ZonedTimestamp</code><br>
<br>
A string representation of a timestamp with timezone information, where the timezone is GMT</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Other data type mappings are described in the following sections.</p>
</div>
<div class="paragraph">
<p>If present, a column&#8217;s default value is propagated to the corresponding field&#8217;s Kafka Connect schema.
Change messages will contain the field&#8217;s default value
(unless an explicit column value had been given), so there should rarely be the need to obtain the default value from the schema.
Passing the default value helps though with satisfying the compatibility rules when <a href="../configuration/avro.html" class="xref page">using Avro</a> as serialization format together with the Confluent schema registry.</p>
</div>
</div>
<div class="sect3">
<h4 id="sql-server-temporal-values"><a class="anchor" href="#sql-server-temporal-values"></a>Temporal values</h4>
<div class="paragraph">
<p>Other than SQL Server&#8217;s <code>DATETIMEOFFSET</code> data type (which contain time zone information), the other temporal types depend on the value of the <code>time.precision.mode</code> configuration property.  When the <code>time.precision.mode</code> configuration property is set to <code>adaptive</code> (the default), then the connector will determine the literal type and semantic type for the temporal types based on the column&#8217;s data type definition so that events <em>exactly</em> represent the values in the database:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server data type</th>
<th class="tableblock halign-left valign-top">Literal type (schema type)</th>
<th class="tableblock halign-left valign-top">Semantic type (schema name) and Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATE</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT32</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.Date</code><br>
<br>
Represents the number of days since the epoch.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TIME(0)</code>, <code>TIME(1)</code>, <code>TIME(2)</code>, <code>TIME(3)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT32</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.Time</code><br>
<br>
Represents the number of milliseconds past midnight, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TIME(4)</code>, <code>TIME(5)</code>, <code>TIME(6)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.MicroTime</code><br>
<br>
Represents the number of microseconds past midnight, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TIME(7)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.NanoTime</code><br>
<br>
Represents the number of nanoseconds past midnight, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.Timestamp</code><br>
<br>
Represents the number of milliseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLDATETIME</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.Timestamp</code><br>
<br>
Represents the number of milliseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME2(0)</code>, <code>DATETIME2(1)</code>, <code>DATETIME2(2)</code>, <code>DATETIME2(3)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.Timestamp</code><br>
<br>
Represents the number of milliseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME2(4)</code>, <code>DATETIME2(5)</code>, <code>DATETIME2(6)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.MicroTimestamp</code><br>
<br>
Represents the number of microseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME2(7)</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.time.NanoTimestamp</code><br>
<br>
Represents the number of nanoseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When the <code>time.precision.mode</code> configuration property is set to <code>connect</code>, then the connector will use the predefined Kafka Connect logical types. This may be useful when consumers only know about the built-in Kafka Connect logical types and are unable to handle variable-precision time values. On the other hand, since SQL Server supports tenth of microsecond precision, the events generated by a connector with the <code>connect</code> time precision mode will <strong>result in a loss of precision</strong> when the database column has a <em>fractional second precision</em> value greater than 3:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 20%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server data type</th>
<th class="tableblock halign-left valign-top">Literal type (schema type)</th>
<th class="tableblock halign-left valign-top">Semantic type (schema name) and Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATE</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT32</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Date</code><br>
<br>
Represents the number of days since the epoch.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>TIME([P])</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Time</code><br>
<br>
Represents the number of milliseconds since midnight, and does not include timezone information. SQL Server allows <code>P</code> to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when <code>P</code> &gt; 3.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Timestamp</code><br>
<br>
Represents the number of milliseconds since the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLDATETIME</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Timestamp</code><br>
<br>
Represents the number of milliseconds past the epoch, and does not include timezone information.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DATETIME2</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>INT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Timestamp</code><br>
<br>
Represents the number of milliseconds since the epoch, and does not include timezone information. SQL Server allows <code>P</code> to be in the range 0-7 to store up to tenth of a microsecond precision, though this mode results in a loss of precision when <code>P</code> &gt; 3.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="sql-server-timestamp-values"><a class="anchor" href="#sql-server-timestamp-values"></a>Timestamp values</h5>
<div class="paragraph">
<p>The <code>DATETIME</code>, <code>SMALLDATETIME</code> and <code>DATETIME2</code> types represent a timestamp without time zone information.
Such columns are converted into an equivalent Kafka Connect value based on UTC.
So for instance the <code>DATETIME2</code> value "2018-06-20 15:13:16.945104" is represented by a <code>io.debezium.time.MicroTimestamp</code> with the value "1529507596945104".</p>
</div>
<div class="paragraph">
<p>Note that the timezone of the JVM running Kafka Connect and Debezium does not affect this conversion.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sql-server-decimal-values"><a class="anchor" href="#sql-server-decimal-values"></a>Decimal values</h4>
<div class="paragraph">
<p>Debezium connectors handle decimals according to the setting of the <a href="#sqlserver-property-decimal-handling-mode"><code>decimal.handling.mode</code> connector configuration property</a>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">decimal.handling.mode=precise</dt>
<dd>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Mappings when <code>decimal.handling.mode=precise</code></caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 15%;">
<col style="width: 55%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server type</th>
<th class="tableblock halign-left valign-top">Literal type (schema type)</th>
<th class="tableblock halign-left valign-top">Semantic type (schema name)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NUMERIC[(P[,S])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BYTES</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Decimal</code><br>
The <code>scale</code> schema parameter contains an integer that represents how many digits the decimal point shifted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DECIMAL[(P[,S])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BYTES</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Decimal</code><br>
The <code>scale</code> schema parameter contains an integer that represents how many digits the decimal point shifted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLMONEY</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BYTES</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Decimal</code><br>
The <code>scale</code> schema parameter contains an integer that represents how many digits the decimal point shifted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MONEY</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>BYTES</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.apache.kafka.connect.data.Decimal</code><br>
The <code>scale</code> schema parameter contains an integer that represents how many digits the decimal point shifted.</p>
</div></div></td>
</tr>
</tbody>
</table>
</dd>
<dt class="hdlist1">decimal.handling.mode=double</dt>
<dd>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Mappings when <code>decimal.handling.mode=double</code></caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server type</th>
<th class="tableblock halign-left valign-top">Literal type</th>
<th class="tableblock halign-left valign-top">Semantic type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NUMERIC[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DECIMAL[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLMONEY[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MONEY[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>FLOAT64</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
</tbody>
</table>
</dd>
<dt class="hdlist1">decimal.handling.mode=string</dt>
<dd>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Mappings when <code>decimal.handling.mode=string</code></caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 30%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">SQL Server type</th>
<th class="tableblock halign-left valign-top">Literal type</th>
<th class="tableblock halign-left valign-top">Semantic type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>NUMERIC[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>DECIMAL[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>SMALLMONEY[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>MONEY[(M[,D])]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>STRING</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-sqlserver"><a class="anchor" href="#setting-up-sqlserver"></a>Setting up SQL Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For Debezium to capture change events from SQL Server tables, a SQL Server administrator with the necessary privileges must first run a query to enable CDC on the database.
The administrator must then enable CDC for each table that you want Debezium to capture.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, JDBC connections to Microsoft SQL Server are protected by SSL encryption.
If SSL is not enabled for a SQL Server database, or if you want to connect to the database without using SSL, you can disable SSL by setting the value of  the <code>database.encrypt</code> property in connector configuration to <code>false</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After CDC is applied, it captures all of the <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> operations that are committed to the tables for which CDC is enabled.
The Debezium connector can then capture these events and emit them to Kafka topics.</p>
</div>
<div class="sect2">
<h3 id="_enabling_cdc_on_the_sql_server_database"><a class="anchor" href="#_enabling_cdc_on_the_sql_server_database"></a>Enabling CDC on the SQL Server database</h3>
<div class="paragraph">
<p>Before you can enable CDC for a table, you must enable it for the SQL Server database.
A SQL Server administrator enables CDC by running a system stored procedure.
System stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You are a member of the <em>sysadmin</em> fixed server role for the SQL Server.</p>
</li>
<li>
<p>You are a db_owner of the database.</p>
</li>
<li>
<p>The SQL Server Agent is running.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The SQL Server CDC feature processes changes that occur in user-created tables only. You cannot enable CDC on the SQL Server <code>master</code> database.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>From the <strong>View</strong> menu in SQL Server Management Studio, click <strong>Template Explorer</strong>.</p>
</li>
<li>
<p>In the <strong>Template Browser</strong>, expand <strong>SQL Server Templates</strong>.</p>
</li>
<li>
<p>Expand <strong>Change Data Capture &gt; Configuration</strong> and then click <strong>Enable Database for CDC</strong>.</p>
</li>
<li>
<p>In the template, replace the database name in the <code>USE</code> statement with the name of the database that you want to enable for CDC.</p>
</li>
<li>
<p>Run the stored procedure <code>sys.sp_cdc_enable_db</code> to enable the database for CDC.</p>
<div class="paragraph">
<p>After the database is enabled for CDC, a schema with the name <code>cdc</code> is created, along with a CDC user, metadata tables, and other system objects.</p>
</div>
<div class="paragraph">
<p>The following example shows how to enable CDC for the database <code>MyDB</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Enabling a SQL Server database for the CDC template</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE MyDB
GO
EXEC sys.sp_cdc_enable_db
GO</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_cdc_on_a_sql_server_table"><a class="anchor" href="#_enabling_cdc_on_a_sql_server_table"></a>Enabling CDC on a SQL Server table</h3>
<div class="paragraph">
<p>A SQL Server administrator must enable change data capture on the source tables that you want to Debezium to capture.
The database must already be enabled for CDC.
To enable CDC on a table, a SQL Server administrator runs the stored procedure <code>sys.sp_cdc_enable_table</code> for the table.
The stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.
SQL Server CDC must be enabled for every table that you want to capture.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>CDC is enabled on the SQL Server database.</p>
</li>
<li>
<p>The SQL Server Agent is running.</p>
</li>
<li>
<p>You are a member of the <code>db_owner</code> fixed database role for the database.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>From the <strong>View</strong> menu in SQL Server Management Studio, click <strong>Template Explorer</strong>.</p>
</li>
<li>
<p>In the <strong>Template Browser</strong>, expand <strong>SQL Server Templates</strong>.</p>
</li>
<li>
<p>Expand <strong>Change Data Capture &gt; Configuration</strong>, and then click <strong>Enable Table Specifying Filegroup Option</strong>.</p>
</li>
<li>
<p>In the template, replace the table name in the <code>USE</code> statement with the name of the table that you want to capture.</p>
</li>
<li>
<p>Run the stored procedure <code>sys.sp_cdc_enable_table</code>.</p>
<div class="paragraph">
<p>The following example shows how to enable CDC for the table <code>MyTable</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Enabling CDC for a SQL Server table</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE MyDB
GO

EXEC sys.sp_cdc_enable_table
@source_schema = N'dbo',
@source_name   = N'MyTable', <i class="conum" data-value="1"></i><b>(1)</b>
@role_name     = N'MyRole',  <i class="conum" data-value="2"></i><b>(2)</b>
@filegroup_name = N'MyDB_CT',<i class="conum" data-value="3"></i><b>(3)</b>
@supports_net_changes = 0
GO</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifies the name of the table that you want to capture.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifies a role <code>MyRole</code> to which you can add users to whom you want to grant <code>SELECT</code> permission on the captured columns of the source table.
Users in the <code>sysadmin</code> or <code>db_owner</code> role also have access to the specified change tables. Set the value of <code>@role_name</code> to <code>NULL</code>, to allow only members in the <code>sysadmin</code> or <code>db_owner</code> to have full access to captured information.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Specifies the <code>filegroup</code> where SQL Server places the change table for the captured table.
The named <code>filegroup</code> must already exist.
It is best not to locate change tables in the same <code>filegroup</code> that you use for source tables.</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_verifying_that_the_user_has_access_to_the_cdc_table"><a class="anchor" href="#_verifying_that_the_user_has_access_to_the_cdc_table"></a>Verifying that the user has access to the CDC table</h3>
<div class="paragraph">
<p>A SQL Server administrator can run a system stored procedure to query a database or table to retrieve its CDC configuration information.
The stored procedures can be run by using SQL Server Management Studio, or by using Transact-SQL.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>You have <code>SELECT</code> permission on all of the captured columns of the capture instance.
Members of the <code>db_owner</code> database role can view information for all of the defined capture instances.</p>
</li>
<li>
<p>You have membership in any gating roles that are defined for the table information that the query includes.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>From the <strong>View</strong> menu in SQL Server Management Studio, click <strong>Object Explorer</strong>.</p>
</li>
<li>
<p>From the Object Explorer, expand <strong>Databases</strong>, and then expand your database object, for example, <strong>MyDB</strong>.</p>
</li>
<li>
<p>Expand <strong>Programmability &gt; Stored Procedures &gt; System Stored Procedures</strong>.</p>
</li>
<li>
<p>Run the <code>sys.sp_cdc_help_change_data_capture</code> stored procedure to query the table.</p>
<div class="paragraph">
<p>Queries should not return empty results.</p>
</div>
<div class="paragraph">
<p>The following example runs the stored procedure <code>sys.sp_cdc_help_change_data_capture</code> on the database <code>MyDB</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Querying a table for CDC configuration information</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE MyDB;
GO
EXEC sys.sp_cdc_help_change_data_capture
GO</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query returns configuration information for each table in the database that is enabled for CDC and that contains change data that the caller is authorized to access.
If the result is empty, verify that the user has privileges to access both the capture instance and the CDC tables.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-on-azure"><a class="anchor" href="#sqlserver-on-azure"></a>SQL Server on Azure</h3>
<div class="paragraph">
<p>The Debezium SQL Server connector can be used with SQL Server on Azure.
Refer to <a href="https://learn.microsoft.com/en-us/samples/azure-samples/azure-sql-db-change-stream-debezium/azure-sql%2D%2Dsql-server-change-stream-with-debezium/">this example</a> for configuring CDC for SQL Server on Azure and using it with Debezium.</p>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-always-on-replica"><a class="anchor" href="#sqlserver-always-on-replica"></a>SQL Server Always On</h3>
<div class="paragraph">
<p>The SQL Server connector can capture changes from an Always On read-only replica.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>Change data capture is configured and enabled on the primary node.
SQL Server does not support CDC directly on replicas.</p>
</li>
<li>
<p>The configuration option <code>database.applicationIntent</code> is set to <code>ReadOnly</code>.
This is required by SQL Server.
When Debezium detects this configuration option, it responds by taking the following actions:</p>
<div class="ulist">
<ul>
<li>
<p>Sets <code>snapshot.isolation.mode</code> to <code>snapshot</code>, which is the only one transaction isolation mode supported for read-only replicas.</p>
</li>
<li>
<p>Commits the (read-only) transaction in every execution of the streaming query loop, which is necessary to get the latest view of CDC data.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_effect_of_sql_server_capture_job_agent_configuration_on_server_load_and_latency"><a class="anchor" href="#_effect_of_sql_server_capture_job_agent_configuration_on_server_load_and_latency"></a>Effect of SQL Server capture job agent configuration on server load and latency</h3>
<div class="paragraph">
<p>When a database administrator enables change data capture for a source table, the capture job agent begins to run.
The agent reads new change event records from the transaction log and replicates the event records to a change data table.
Between the time that a change is committed in the source table, and the time that the change appears in the corresponding change table, there is always a small latency interval.
This latency interval represents a gap between when changes occur in the source table and when they become available for Debezium to stream to Apache Kafka.</p>
</div>
<div class="paragraph">
<p>Ideally, for applications that must respond quickly to changes in data, you want to maintain close synchronization between the source and change tables.
You might imagine that running the capture agent to continuously process change events as rapidly as possible might result in increased throughput and reduced latency&#8201;&#8212;&#8201;populating change tables with new event records as soon as possible after the events occur, in near real time.
However, this is not necessarily the case.
There is a performance penalty to pay in the pursuit of more immediate synchronization.
Each time that the capture job agent queries the database for new event records, it increases the CPU load on the database host.
The additional load on the server can have a negative effect on overall database performance, and potentially reduce transaction efficiency, especially during times of peak database use.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to monitor database metrics so that you know if the database reaches the point where the server can no longer support the capture agent&#8217;s level of activity.
If you notice performance problems, there are SQL Server capture agent settings that you can modify to help balance the overall CPU load on the database host with a tolerable degree of latency.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sql_server_capture_job_agent_configuration_parameters"><a class="anchor" href="#_sql_server_capture_job_agent_configuration_parameters"></a>SQL Server capture job agent configuration parameters</h3>
<div class="paragraph">
<p>On SQL Server, parameters that control the behavior of the capture job agent are defined in the SQL Server table <a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-tables/dbo-cdc-jobs-transact-sql?view=latest"><code>msdb.dbo.cdc_jobs</code></a>.
If you experience performance issues while running the capture job agent, adjust capture jobs settings to reduce CPU load by running the <a href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sys-sp-cdc-change-job-transact-sql?view=latest"><code>sys.sp_cdc_change_job</code></a> stored procedure and supplying new values.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Specific guidance about how to configure SQL Server capture job agent parameters is beyond the scope of this documentation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following parameters are the most significant for modifying capture agent behavior for use with the Debezium SQL Server connector:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pollinginterval</code></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Specifies the number of seconds that the capture agent waits between log scan cycles.</p>
</li>
<li>
<p>A higher value reduces the load on the database host and increases latency.</p>
</li>
<li>
<p>A value of <code>0</code> specifies no wait between scans.</p>
</li>
<li>
<p>The default value is <code>5</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>maxtrans</code></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Specifies the maximum number of transactions to process during each log scan cycle.
After the capture job processes the specified number of transactions, it pauses for the length of time that the <code>pollinginterval</code> specifies before the next scan begins.</p>
</li>
<li>
<p>A lower value reduces the load on the database host and increases latency.</p>
</li>
<li>
<p>The default value is <code>500</code>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>maxscans</code></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Specifies a limit on the number of scan cycles that the capture job can attempt in capturing the full contents of the database transaction log.
If the <code>continuous</code> parameter is set to <code>1</code>, the job pauses for the length of time that the <code>pollinginterval</code> specifies before it resumes scanning.</p>
</li>
<li>
<p>A lower values reduces the load on the database host and increases latency.</p>
</li>
<li>
<p>The default value is <code>10</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="ulist">
<div class="title">Additional resources</div>
<ul>
<li>
<p>For more information about capture agent parameters, see the SQL Server documentation.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sqlserver-deploying-a-connector"><a class="anchor" href="#sqlserver-deploying-a-connector"></a>Deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To deploy a Debezium SQL Server connector, you install the Debezium SQL Server connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p><a href="https://zookeeper.apache.org/">Apache ZooKeeper</a>, <a href="http://kafka.apache.org/">Apache Kafka</a>, and <a href="https://kafka.apache.org/documentation.html#connect">Kafka Connect</a> are installed.</p>
</li>
<li>
<p>SQL Server is installed, is <a href="#setting-up-sqlserver">configured for CDC</a>, and is ready to be used with the Debezium connector.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Download the Debezium <a href="https://repo1.maven.org/maven2/io/debezium/debezium-connector-sqlserver/2.7.2.Final/debezium-connector-sqlserver-2.7.2.Final-plugin.tar.gz">SQL Server connector plug-in archive</a></p>
</li>
<li>
<p>Extract the files into your Kafka Connect environment.</p>
</li>
<li>
<p>Add the directory with the JAR files to <a href="https://kafka.apache.org/documentation/#connectconfigs">Kafka Connect&#8217;s <code>plugin.path</code></a>.</p>
</li>
<li>
<p><a href="#sqlserver-example-configuration">Configure the connector</a> and <a href="#sqlserver-adding-connector-configuration">add the configuration to your Kafka Connect cluster.</a></p>
</li>
<li>
<p>Restart your Kafka Connect process to pick up the new JAR files.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you are working with immutable containers, see <a href="https://quay.io/organization/debezium">Debezium&#8217;s container images</a> for Åpache ZooKeeper, Apache Kafka, and Kafka Connect.
You can pull the official <a href="https://hub.docker.com/_/microsoft-mssql-server">container images for Microsoft SQL Server on Linux</a> from Docker Hub.</p>
</div>
<div class="paragraph">
<p>You can also <a href="../operations/openshift.html" class="xref page">run Debezium on Kubernetes and OpenShift</a>.</p>
</div>
<div class="sect2">
<h3 id="sqlserver-example-configuration"><a class="anchor" href="#sqlserver-example-configuration"></a>SQL Server connector configuration example</h3>
<div class="paragraph">
<p>Following is an example of the configuration for a connector instance that captures data from a SQL Server server at port 1433 on 192.168.99.100, which we logically name <code>fullfillment</code>.
Typically, you configure the Debezium SQL Server connector in a JSON file by setting the configuration properties that are available for the connector.</p>
</div>
<div class="paragraph">
<p>You can choose to produce events for a subset of the schemas and tables in a database.
Optionally, you can ignore, mask, or truncate columns that contain sensitive data, that are larger than a specified size, or that you do not need.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
    "name": "inventory-connector", <i class="conum" data-value="1"></i><b>(1)</b>
    "config": {
        "connector.class": "io.debezium.connector.sqlserver.SqlServerConnector", <i class="conum" data-value="2"></i><b>(2)</b>
        "database.hostname": "192.168.99.100", <i class="conum" data-value="3"></i><b>(3)</b>
        "database.port": "1433", <i class="conum" data-value="4"></i><b>(4)</b>
        "database.user": "sa", <i class="conum" data-value="5"></i><b>(5)</b>
        "database.password": "Password!", <i class="conum" data-value="6"></i><b>(6)</b>
        "database.names": "testDB1,testDB2", <i class="conum" data-value="7"></i><b>(7)</b>
        "topic.prefix": "fullfillment", <i class="conum" data-value="8"></i><b>(8)</b>
        "table.include.list": "dbo.customers", <i class="conum" data-value="9"></i><b>(9)</b>
        "schema.history.internal.kafka.bootstrap.servers": "kafka:9092", <i class="conum" data-value="10"></i><b>(10)</b>
        "schema.history.internal.kafka.topic": "schemahistory.fullfillment", <i class="conum" data-value="11"></i><b>(11)</b>
        "database.ssl.truststore": "path/to/trust-store", <i class="conum" data-value="12"></i><b>(12)</b>
        "database.ssl.truststore.password": "password-for-trust-store" <i class="conum" data-value="13"></i><b>(13)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The name of our connector when we register it with a Kafka Connect service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The name of this SQL Server connector class.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The address of the SQL Server instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The port number of the SQL Server instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The name of the SQL Server user</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The password for the SQL Server user</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The name of the database to capture changes from.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The topic prefix for the SQL Server instance/cluster, which forms a namespace and is used in all the names of the Kafka topics to which the connector writes, the Kafka Connect schema names, and the namespaces of the corresponding Avro schema when the <a href="../configuration/avro.html#avro-serialization" class="xref page">Avro converter</a> is used.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>A list of all tables whose changes Debezium should capture.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The list of Kafka brokers that this connector will use to write and recover DDL statements to the database schema history topic.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>The name of the database schema history topic where the connector will write and recover DDL statements. This topic is for internal use only and should not be used by consumers.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>The path to the SSL truststore that stores the server&#8217;s signer certificates.
This property is required unless database encryption is disabled (<code>database.encrypt=false</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>The SSL truststore password.
This property is required unless database encryption is disabled (<code>database.encrypt=false</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For the complete list of the configuration properties that you can set for the Debezium SQL Server connector, see <a href="#sqlserver-connector-properties">SQL Server connector properties</a>.</p>
</div>
<div class="paragraph">
<p>You can send this configuration with a <code>POST</code> command to a running Kafka Connect service.
The service records the configuration and start up the one connector task that performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Connects to the SQL Server database.</p>
</li>
<li>
<p>Reads the transaction log.</p>
</li>
<li>
<p>Records change events to Kafka topics.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-adding-connector-configuration"><a class="anchor" href="#sqlserver-adding-connector-configuration"></a>Adding connector configuration</h3>
<div class="paragraph">
<p>To start running a Debezium SQL Server connector, create a connector configuration, and add the configuration to your Kafka Connect cluster.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p><a href="#setting-up-sqlserver">CDC is enabled on SQL Server</a>.</p>
</li>
<li>
<p>The Debezium SQL Server connector is installed.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Create a configuration for the SQL Server connector.</p>
</li>
<li>
<p>Use the <a href="https://kafka.apache.org/documentation/#connect_rest">Kafka Connect REST API</a> to add that connector configuration to your Kafka Connect cluster.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">Results</div>
<p>When the connector starts, it <a href="#sqlserver-snapshots">performs a consistent snapshot</a> of the SQL Server databases that the connector is configured for.
The connector then starts generating data change events for row-level operations and streaming the change event records to Kafka topics.</p>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-connector-properties"><a class="anchor" href="#sqlserver-connector-properties"></a>Connector properties</h3>
<div class="paragraph">
<p>The Debezium SQL Server connector has numerous configuration properties that you can use to achieve the right connector behavior for your application.
Many properties have default values.</p>
</div>
<div class="paragraph">
<p>Information about the properties is organized as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sqlserver-required-connector-configuration-properties">Required connector configuration properties</a></p>
</li>
<li>
<p><a href="#sqlserver-advanced-connector-configuration-properties">Advanced connector configuration properties</a></p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-database-history-configuration-properties">Database schema history connector configuration properties</a> that control how Debezium processes events that it reads from the database schema history topic.</p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-pass-through-properties">Pass-through SQL Server connector configuration properties</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#debezium-sqlserver-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients">Pass-through database schema history properties for configuring producer and consumer clients</a></p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-pass-through-kafka-signals-configuration-properties">Pass-through Kafka signals configuration properties</a></p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-pass-through-signals-kafka-consumer-client-configuration-properties">Pass-through Kafka signals consumer client configuration properties</a></p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-pass-through-kafka-sink-notification-configuration-properties">Pass-through sink notification configuration properties</a></p>
</li>
<li>
<p><a href="#debezium-sqlserver-connector-pass-through-database-driver-configuration-properties">Pass-through database driver configuration properties</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="sqlserver-required-connector-configuration-properties"><a class="anchor" href="#sqlserver-required-connector-configuration-properties"></a>Required Debezium SQL Server connector configuration properties</h4>
<div class="paragraph">
<p>The following configuration properties are <em>required</em> unless a default value is available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-name"></a><a href="#sqlserver-property-name"><code>name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Unique name for the connector. Attempting to register again with the same name will fail. (This property is required by all Kafka Connect connectors.)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-connector-class"></a><a href="#sqlserver-property-connector-class"><code>connector.class</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the Java class for the connector. Always use a value of <code>io.debezium.connector.sqlserver.SqlServerConnector</code> for the SQL Server connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-tasks-max"></a><a href="#sqlserver-property-tasks-max"><code>tasks.max</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the maximum number of tasks that the connector can use to capture data from the database instance.
If the <a href="#sqlserver-property-database-names"><code>database.names</code></a> list contains more than one element, you can increase the value of this property to a number less than or equal to the number of elements in the list.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-hostname"></a><a href="#sqlserver-property-database-hostname"><code>database.hostname</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>IP address or hostname of the SQL Server database server.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-port"></a><a href="#sqlserver-property-database-port"><code>database.port</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1433</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Integer port number of the SQL Server database server.
If both <code>database.port</code> and <code>database.instance</code> are specified, <code>database.instance</code> is ignored.
See <a href="https://learn.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url">JDBC driver for SQL server documentation</a> for more details.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-user"></a><a href="#sqlserver-property-database-user"><code>database.user</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Username to use when connecting to the SQL Server database server.
Can be omitted when using Kerberos authentication, which can be configured using <a href="#debezium-sqlserver-connector-pass-through-database-driver-configuration-properties">pass-through properties</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-password"></a><a href="#sqlserver-property-database-password"><code>database.password</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Password to use when connecting to the SQL Server database server.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-instance"></a> <a href="#sqlserver-property-database-instance"><code>database.instance</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the instance name of the <a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/database-engine-instances-sql-server?view=sql-server-latest#instances">SQL Server named instance</a>.
If both <code>database.port</code> and <code>database.instance</code> are specified, <code>database.instance</code> is ignored.
See <a href="https://learn.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url">JDBC driver for SQL server documentation</a> for more details.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-names"></a><a href="#sqlserver-property-database-names"><code>database.names</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The comma-separated list of the SQL Server database names from which to stream the changes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-prefix"></a><a href="#sqlserver-property-topic-prefix"><code>topic.prefix</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Topic prefix that provides a namespace for the SQL Server database server that you want Debezium to capture.
The prefix should be unique across all other connectors, since it is used as the prefix for all Kafka topic names that receive records from this connector.
Only alphanumeric characters, hyphens, dots and underscores must be used in the database server logical name.<br>
<br></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Do not change the value of this property.
If you change the name value, after a restart, instead of continuing to emit events to the original topics, the connector emits subsequent events to topics whose names are based on the new value.
The connector is also unable to recover its database schema history topic.</p>
</div>
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-schema-include-list"></a><a href="#sqlserver-property-schema-include-list"><code>schema.include.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match names of schemas for which you <strong>want</strong> to capture changes.
Any schema name not included in <code>schema.include.list</code> is excluded from having its changes captured.
By default, the connector captures changes for all non-system schemas.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a schema, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the schema; it does not match substrings that might be present in a schema name.<br>
If you include this property in the configuration, do not also set the <code>schema.exclude.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-schema-exclude-list"></a><a href="#sqlserver-property-schema-exclude-list"><code>schema.exclude.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match names of schemas for which you <strong>do not</strong> want to capture changes.
Any schema whose name is not included in <code>schema.exclude.list</code> has its changes captured, with the exception of system schemas.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a schema, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the schema; it does not match substrings that might be present in a schema name.<br>
If you include this property in the configuration, do not set the <code>schema.include.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-table-include-list"></a><a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match fully-qualified table identifiers for tables that you want Debezium to capture.
By default, the connector captures all non-system tables for the designated schemas.
When this property is set, the connector captures changes only from the specified tables.
Each identifier is of the form <em>schemaName</em>.<em>tableName</em>.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a table, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.<br>
If you include this property in the configuration, do not also set the <code>table.exclude.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-table-exclude-list"></a><a href="#sqlserver-property-table-exclude-list"><code>table.exclude.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match fully-qualified table identifiers for the tables that you want to exclude from being captured.
Debezium captures all tables that are not included in <code>table.exclude.list</code>.
Each identifier is of the form <em>schemaName</em>.<em>tableName</em>.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a table, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.<br>
If you include this property in the configuration, do not also set the <code>table.include.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-include-list"></a><a href="#sqlserver-property-column-include-list"><code>column.include.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be included in the change event message values.
Fully-qualified names for columns are of the form <em>schemaName</em>.<em>tableName</em>.<em>columnName</em>.<br></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Each change event record that Debezium emits for a table includes an event key that contains fields for each column in the table&#8217;s primary key or unique key.
To ensure that event keys are generated correctly, if you set this property, be sure to explicitly list the primary key columns of any captured tables.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To match the name of a column, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.<br>
If you include this property in the configuration, do not also set the <code>column.exclude.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-exclude-list"></a><a href="#sqlserver-property-column-exclude-list"><code>column.exclude.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>empty string</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional comma-separated list of regular expressions that match the fully-qualified names of columns that should be excluded from change event message values.
Fully-qualified names for columns are of the form <em>schemaName</em>.<em>tableName</em>.<em>columnName</em>.
Note that primary key columns are always included in the event&#8217;s key, also if excluded from the value.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a column, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; it does not match substrings that might be present in a column name.<br>
If you include this property in the configuration, do not also set the <code>column.include.list</code> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-skip-messages-without-change"></a><a href="#sqlserver-property-skip-messages-without-change"><code>skip.messages.without.change</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether to skip publishing messages when there is no change in included columns. This would essentially filter messages if there is no change in columns included as per <code>column.include.list</code> or <code>column.exclude.list</code> properties.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-mask-hash"></a><a href="#sqlserver-property-column-mask-hash"><code>column.mask.hash.<em>hashAlgorithm</em>.with.salt.<em>salt</em></code></a>;
<a id="sqlserver-property-column-mask-hash-v2"></a><a href="#sqlserver-property-column-mask-hash-v2"><code>column.mask.hash.v2.<em>hashAlgorithm</em>.with.salt.<em>salt</em></code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Fully-qualified names for columns are of the form <em>`&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em>.<em>&lt;columnName&gt;`.<br>
To match the name of a column Debezium applies the regular expression that you specify as an _anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.
In the resulting change event record, the values for the specified columns are replaced with pseudonyms.<br></p>
</div>
<div class="paragraph">
<p>A pseudonym consists of the hashed value that results from applying the specified <em>hashAlgorithm</em> and <em>salt</em>.
Based on the hash function that is used, referential integrity is maintained, while column values are replaced with pseudonyms.
Supported hash functions are described in the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#MessageDigest">MessageDigest section</a> of the Java Cryptography Architecture Standard Algorithm Name Documentation.<br>
<br>
In the following example, <code>CzQMA0cB5K</code> is a randomly selected salt.<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre>column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName</pre>
</div>
</div>
<div class="paragraph">
<p>If necessary, the pseudonym is automatically shortened to the length of the column.
The connector configuration can include multiple properties that specify different hash algorithms and salts.<br>
<br>
Depending on the <em>hashAlgorithm</em> used, the <em>salt</em> selected, and the actual data set, the resulting data set might not be completely masked.<br>
<br>
Hashing strategy version 2 should be used to ensure fidelity if the value is being hashed in different places or systems.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-time-precision-mode"></a><a href="#sqlserver-property-time-precision-mode"><code>time.precision.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>adaptive</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Time, date, and timestamps can be represented with different kinds of precision, including: <code>adaptive</code> (the default) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column&#8217;s type; or <code>connect</code> always represents time and timestamp values using Kafka Connect&#8217;s built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.
For more information, see <a href="#sql-server-temporal-values">temporal values</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-decimal-handling-mode"></a><a href="#sqlserver-property-decimal-handling-mode"><code>decimal.handling.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>precise</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how the connector should handle values for <code>DECIMAL</code> and <code>NUMERIC</code> columns:<br>
<br>
<code>precise</code> (the default) represents them precisely using <code>java.math.BigDecimal</code> values represented in change events in a binary form.<br>
<br>
<code>double</code> represents them using <code>double</code> values, which may result in a loss of precision but is easier to use.<br>
<br>
<code>string</code> encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-include-schema-changes"></a><a href="#sqlserver-property-include-schema-changes"><code>include.schema.changes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded with a key that contains the database name and a value that is a JSON structure that describes the schema update. This is independent of how the connector internally records database schema history. The default is <code>true</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-tombstones-on-delete"></a><a href="#sqlserver-property-tombstones-on-delete"><code>tombstones.on.delete</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>true</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls whether a <em>delete</em> event is followed by a tombstone event.<br>
<br>
<code>true</code> - a delete operation is represented by a <em>delete</em> event and a subsequent tombstone event. <br>
<br>
<code>false</code> - only a <em>delete</em> event is emitted.<br>
<br>
After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row in case <a href="https://kafka.apache.org/documentation/#compaction">log compaction</a> is enabled for the topic.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-truncate-to-length-chars"></a><a href="#sqlserver-property-column-truncate-to-length-chars"><code>column.truncate.to.<em>length</em>.chars</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want to truncate the data in a set of columns when it exceeds the number of characters specified by the <em>length</em> in the property name.
Set <code>length</code> to a positive integer value, for example, <code>column.truncate.to.20.chars</code>.</p>
</div>
<div class="paragraph">
<p>The fully-qualified name of a column observes the following format: <code><em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em>.<em>&lt;columnName&gt;</em></code>.
To match the name of a column, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.</p>
</div>
<div class="paragraph">
<p>You can specify multiple properties with different lengths in a single configuration.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-mask-with-length-chars"></a><a href="#sqlserver-property-column-mask-with-length-chars"><code>column.mask.with.<em>length</em>.chars</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em>
Fully-qualified names for columns are of the form <em>schemaName</em>.<em>tableName</em>.<em>columnName</em>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns.
Set this property if you want the connector to mask the values for a set of columns, for example, if they contain sensitive data.
Set <code><em>length</em></code> to a positive integer to replace data in the specified columns with the number of asterisk (<code>*</code>) characters specified by the <em>length</em> in the property name.
Set <em>length</em> to <code>0</code> (zero) to replace data in the specified columns with an empty string.</p>
</div>
<div class="paragraph">
<p>The fully-qualified name of a column observes the following format: <em>schemaName</em>.<em>tableName</em>.<em>columnName</em>.
To match the name of a column, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.</p>
</div>
<div class="paragraph">
<p>You can specify multiple properties with different lengths in a single configuration.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-column-propagate-source-type"></a><a href="#sqlserver-property-column-propagate-source-type"><code>column.propagate.source.type</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match the fully-qualified names of columns for which you want the connector to emit extra parameters that represent column metadata.
When this property is set, the connector adds the following fields to the schema of event records:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>__debezium.source.column.type</code><br></p>
</li>
<li>
<p><code>__debezium.source.column.length</code><br></p>
</li>
<li>
<p><code>__debezium.source.column.scale</code><br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These parameters propagate a column&#8217;s original type name and length (for variable-width types), respectively.<br>
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.</p>
</div>
<div class="paragraph">
<p>The fully-qualified name of a column observes the following format: <em>schemaName</em>.<em>tableName</em>.<em>columnName</em>.<br>
To match the name of a column, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the column; the expression does not match substrings that might be present in a column name.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-datatype-propagate-source-type"></a><a href="#sqlserver-property-datatype-propagate-source-type"><code>datatype.propagate.source.type</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that specify the fully-qualified names of data types that are defined for columns in a database.
When this property is set, for columns with matching data types, the connector emits event records that include the following extra fields in their schema:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>__debezium.source.column.type</code><br></p>
</li>
<li>
<p><code>__debezium.source.column.length</code><br></p>
</li>
<li>
<p><code>__debezium.source.column.scale</code><br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These parameters propagate a column&#8217;s original type name and length (for variable-width types), respectively.<br>
Enabling the connector to emit this extra data can assist in properly sizing specific numeric or character-based columns in sink databases.</p>
</div>
<div class="paragraph">
<p>The fully-qualified name of a column observes the following format: <em>schemaName</em>.<em>tableName</em>.<em>typeName</em>.<br>
To match the name of a data type, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the data type; the expression does not match substrings that might be present in a type name.</p>
</div>
<div class="paragraph">
<p>For the list of SQL Server-specific data type names, see the <a href="#sqlserver-data-types">SQL Server data type mappings</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-message-key-columns"></a><a href="#sqlserver-property-message-key-columns"><code>message.key.columns</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>n/a</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A list of expressions that specify the columns that the connector uses to form custom message keys for change event records that it publishes to the Kafka topics for specified tables.</p>
</div>
<div class="paragraph">
<p>By default, Debezium uses the primary key column of a table as the message key for records that it emits.
In place of the default, or to specify a key for tables that lack a primary key, you can configure custom message keys based on one or more columns.<br>
<br>
To establish a custom message key for a table, list the table, followed by the columns to use as the message key.
Each list entry takes the following format:<br>
<br>
<code><em>&lt;fully-qualified_tableName&gt;</em>:<em>&lt;keyColumn&gt;</em>,<em>&lt;keyColumn&gt;</em></code><br>
<br>
To base a table key on multiple column names, insert commas between the column names.</p>
</div>
<div class="paragraph">
<p>Each fully-qualified table name is a regular expression in the following format:<br>
<br>
<code><em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em></code><br>
<br>
The property can include entries for multiple tables.
Use a semicolon to separate table entries in the list.<br>
<br>
The following example sets the message key for the tables <code>inventory.customers</code> and <code>purchase.orders</code>:<br>
<br>
<code>inventory.customers:pk1,pk2;(.*).purchaseorders:pk3,pk4</code><br>
<br>
For the table <code>inventory.customer</code>, the columns <code>pk1</code> and <code>pk2</code> are specified as the message key.
For the <code>purchaseorders</code> tables in any schema, the columns <code>pk3</code> and <code>pk4</code> server as the message key.</p>
</div>
<div class="paragraph">
<p>There is no limit to the number of columns that you use to create custom message keys.
However, it&#8217;s best to use the minimum number that are required to specify a unique key.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-binary-handling-mode"></a><a href="#sqlserver-property-binary-handling-mode"><code>binary.handling.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>bytes</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how binary (<code>binary</code>, <code>varbinary</code>) columns should be represented in change events, including: <code>bytes</code> represents binary data as byte array (default), <code>base64</code> represents binary data as base64-encoded String, <code>base64-url-safe</code> represents binary data as base64-url-safe-encoded String, <code>hex</code> represents binary data as hex-encoded (base16) String</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-schema-name-adjustment-mode"></a><a href="#sqlserver-property-schema-name-adjustment-mode"><code>schema.name.adjustment.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>none</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how schema names should be adjusted for compatibility with the message converter used by the connector. Possible settings: <br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> does not apply any adjustment.<br></p>
</li>
<li>
<p><code>avro</code> replaces the characters that cannot be used in the Avro type name with underscore.<br></p>
</li>
<li>
<p><code>avro_unicode</code> replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java<br></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-field-name-adjustment-mode"></a><a href="#sqlserver-property-field-name-adjustment-mode"><code>field.name.adjustment.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>none</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how field names should be adjusted for compatibility with the message converter used by the connector. Possible settings: <br></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> does not apply any adjustment.<br></p>
</li>
<li>
<p><code>avro</code> replaces the characters that cannot be used in the Avro type name with underscore.<br></p>
</li>
<li>
<p><code>avro_unicode</code> replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see <a href="../configuration/avro.html#avro-naming" class="xref page">Avro naming</a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="sqlserver-advanced-connector-configuration-properties"><a class="anchor" href="#sqlserver-advanced-connector-configuration-properties"></a>Advanced SQL Server connector configuration properties</h4>
<div class="paragraph">
<p>The following <em>advanced</em> configuration properties have good defaults that will work in most situations and therefore rarely need to be specified in the connector&#8217;s configuration.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 25%;">
<col style="width: 45%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-converters"></a><a href="#sqlserver-property-converters"><code>converters</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Enumerates a comma-separated list of the symbolic names of the <a href="../development/converters.html#custom-converters" class="xref page">custom converter</a> instances that the connector can use.
For example,<br></p>
</div>
<div class="paragraph">
<p><code>isbn</code></p>
</div>
<div class="paragraph">
<p>You must set the <code>converters</code> property to enable the connector to use a custom converter.</p>
</div>
<div class="paragraph">
<p>For each converter that you configure for a connector, you must also add a <code>.type</code> property, which specifies the fully-qualified name of the class that implements the converter interface.
The <code>.type</code> property uses the following format:<br></p>
</div>
<div class="paragraph">
<p><code><em>&lt;converterSymbolicName&gt;</em>.type</code><br></p>
</div>
<div class="paragraph">
<p>For example,<br></p>
</div>
<div class="literalblock">
<div class="content">
<pre>isbn.type: io.debezium.test.IsbnConverter</pre>
</div>
</div>
<div class="paragraph">
<p>If you want to further control the behavior of a configured converter, you can add one or more configuration parameters to pass values to the converter.
To associate any additional configuration parameter with a converter, prefix the parameter names with the symbolic name of the converter.
For example,<br></p>
</div>
<div class="literalblock">
<div class="content">
<pre>isbn.schema.name: io.debezium.sqlserver.type.Isbn</pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode"></a><a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>initial</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A mode for taking an initial snapshot of the structure and optionally data of captured tables.
Once the snapshot is complete, the connector will continue reading change events from the database&#8217;s redo logs.
The following values are supported:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>always</code></dt>
<dd>
<p>Perform snapshot on each connector start.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.</p>
</dd>
<dt class="hdlist1"><code>initial</code></dt>
<dd>
<p>The connector performs a database snapshot as described in the <a href="#sqlserver-default-workflow-for-performing-an-initial-snapshot">default workflow for creating an initial snapshot</a>.
After the snapshot completes, the connector begins to stream event records for subsequent database changes.</p>
</dd>
<dt class="hdlist1"><code>initial_only</code></dt>
<dd>
<p>The connector performs a database snapshot and stops before streaming any change event records, not allowing any subsequent change events to be captured.</p>
</dd>
<dt class="hdlist1"><code>schema_only</code></dt>
<dd>
<p>Deprecated, see <code>no_data</code>.</p>
</dd>
<dt class="hdlist1"><code>no_data</code></dt>
<dd>
<p>The connector captures the structure of all relevant tables, performing all the steps described in the <a href="#sqlserver-default-workflow-for-performing-an-initial-snapshot">default snapshot workflow</a>, except that it does not create <code>READ</code> events to represent the data set at the point of the connector&#8217;s start-up (Step 7.b).</p>
</dd>
<dt class="hdlist1"><code>recovery</code></dt>
<dd>
<p>Set this option to restore a database schema history topic that is lost or corrupted.
After a restart, the connector runs a snapshot that rebuilds the topic from the source tables.
You can also set the property to periodically prune a database schema history topic that experiences unexpected growth.<br></p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Do not use this mode to perform a snapshot if schema changes were committed to the database after the last connector shutdown.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>when_needed</code></dt>
<dd>
<p>After the connector starts, it performs a snapshot only if it detects one of the following circumstances:</p>
<div class="ulist">
<ul>
<li>
<p>It cannot detect any topic offsets.</p>
</li>
<li>
<p>A previously recorded offset specifies a log position that is not available on the server.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>configuration_based</code></dt>
<dd>
<p>With this option, you control snapshot behavior through a set of connector properties that have the prefix 'snapshot.mode.configuration.based'.</p>
</dd>
<dt class="hdlist1"><code>custom</code></dt>
<dd>
<p>The <code>custom</code> snapshot mode lets you inject your own implementation of the <code>io.debezium.spi.snapshot.Snapshotter</code> interface.
Set the <code>snapshot.mode.custom.name</code> configuration property to the name provided by the <code>name()</code> method of your implementation.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For more information, see <a href="#connector-custom-snapshot">custom snapshotter SPI</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-configuration-based-snapshot-data"></a><a href="#sqlserver-property-configuration-based-snapshot-data"><code>snapshot.mode.configuration.based.snapshot.data</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>false</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>snapshot.mode</code> is set to <code>configuration_based</code>, set this property to specify whether the connector includes table data when it performs a snapshot.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-configuration-based-snapshot-schema"></a><a href="#sqlserver-property-configuration-based-snapshot-schema"><code>snapshot.mode.configuration.based.snapshot.schema</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>false</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>snapshot.mode</code> is set to <code>configuration_based</code>, set this property to specify whether the connector includes the table schema when it performs a snapshot.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-configuration-based-start-stream"></a><a href="#sqlserver-property-configuration-based-start-stream"><code>snapshot.mode.configuration.based.start.stream</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>false</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>snapshot.mode</code> is set to <code>configuration_based</code>, set this property to specify whether the connector begins to stream change events after a snapshot completes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-configuration-based-snapshot-on-schema-error"></a><a href="#sqlserver-property-configuration-based-snapshot-on-schema-error"><code>snapshot.mode.configuration.based.snapshot.on.schema.error</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>false</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>snapshot.mode</code> is set to <code>configuration_based</code>, set this property to specify whether the connector includes table schema in a snapshot if the schema history topic is not available.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-configuration-based-snapshot-on-data-error"></a><a href="#sqlserver-property-configuration-based-snapshot-on-data-error"><code>snapshot.mode.configuration.based.snapshot.on.data.error</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>false</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the <code>snapshot.mode</code> is set to <code>configuration_based</code>, this property specifies whether the connector attempts to snapshot table data if it does not find the last committed offset in the transaction log.<br>
Set the value to <code>true</code> to instruct the connector to perform a new snapshot.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-mode-custom-name"></a><a href="#sqlserver-property-snapshot-mode-custom-name"><code>snapshot.mode.custom.name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If <code>snapshot.mode</code> is set to <code>custom</code>, use this setting to specify the name of the custom implementation that is provided in the <code>name()</code> method that is defined in the 'io.debezium.spi.snapshot.Snapshotter' interface.
After a connector restart, Debezium calls the specified custom implementation to determine whether to perform a snapshot.
For more information, see <a href="#connector-custom-snapshot">custom snapshotter SPI</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-locking-mode"></a><a href="#sqlserver-property-snapshot-locking-mode"><code>snapshot.locking.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>exclusive</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls whether and for how long the connector holds a table lock. Table locks prevent certain types of changes table operations from occurring while the connector performs a snapshot.
You can set the following values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>exclusive</code></dt>
<dd>
<p>Controls how the connector holds locks on tables while performing the schema snapshot when <code>snapshot.isolation.mode</code> is <code>REPEATABLE_READ</code> or <code>EXCLUSIVE</code>.<br>
The connector will hold a table lock for exclusive table access for just the initial portion of the snapshot
while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from
each table, and this is done using a flashback query that requires no locks. However, in some cases it may be desirable to avoid
locks entirely which can be done by specifying <code>none</code>. This mode is only safe to use if no schema changes are happening while the
snapshot is taken.</p>
</dd>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>Prevents the connector from acquiring any table locks during the snapshot.
Use this setting only if no schema changes might occur during the creation of the snapshot.</p>
</dd>
<dt class="hdlist1"><code>custom</code></dt>
<dd>
<p>The connector performs a snapshot according to the implementation specified by the <a href="#sqlserver-property-snapshot-locking-mode-custom-name"><code>snapshot.locking.mode.custom.name</code></a> property, which is a custom implementation of the <code>io.debezium.spi.snapshot.SnapshotLock</code> interface.</p>
</dd>
</dl>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-locking-mode-custom-name"></a><a href="#sqlserver-property-snapshot-locking-mode-custom-name"><code>snapshot.locking.mode.custom.name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When <code>snapshot.locking.mode</code> is set as <code>custom</code>, use this setting to specify the name of the custom implementation provided in the <code>name()</code> method that is defined by the 'io.debezium.spi.snapshot.SnapshotLock' interface.
For more information, see <a href="#connector-custom-snapshot">custom snapshotter SPI</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-query-mode"></a><a href="#sqlserver-property-snapshot-query-mode"><code>snapshot.query.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>select_all</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how the connector queries data while performing a snapshot.<br>
Set one of the following options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>select_all</code></dt>
<dd>
<p>The connector performs a <code>select all</code> query by default, optionally adjusting the columns selected based on the column include and exclude list configurations.</p>
</dd>
<dt class="hdlist1"><code>custom</code></dt>
<dd>
<p>The connector performs a snapshot query according to the implementation specified by the <a href="#sqlserver-property-snapshot-snapshot-query-mode-custom-name"><code>snapshot.query.mode.custom.name</code></a> property, which defines a custom implementation of the <code>io.debezium.spi.snapshot.SnapshotQuery</code> interface.<br></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This setting enables you to manage snapshot content in a more flexible manner compared to using the <a href="#sqlserver-property-snapshot-select-statement-overrides"><code>snapshot.select.statement.overrides</code></a> property.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-snapshot-query-mode-custom-name"></a><a href="#sqlserver-property-snapshot-query-mode-custom-name"><code>snapshot.query.mode.custom.name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When <a href="#sqlserver-property-snapshot-query-mode"><code>snapshot.query.mode</code></a> is set to <code>custom</code>, use this setting to specify the name of the custom implementation provided in the <code>name()</code> method that is defined by the 'io.debezium.spi.snapshot.SnapshotQuery' interface.
For more information, see <a href="#connector-custom-snapshot">custom snapshotter SPI</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-include-collection-list"></a><a href="#sqlserver-property-snapshot-include-collection-list"><code>snapshot.include.collection.list</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All tables specified in <code>table.include.list</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An optional, comma-separated list of regular expressions that match the fully-qualified names (<code><em>&lt;dbName&gt;</em>.<em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em></code>) of the tables to include in a snapshot.
The specified items must be named in the connector&#8217;s <a href="#sqlserver-property-table-include-list"><code>table.include.list</code></a> property.
This property takes effect only if the connector&#8217;s <a href="#sqlserver-property-snapshot-mode"><code>snapshot.mode</code></a> property is set to a value other than <code>never</code>.<br>
This property does not affect the behavior of incremental snapshots.<br></p>
</div>
<div class="paragraph">
<p>To match the name of a table, Debezium applies the regular expression that you specify as an <em>anchored</em> regular expression.
That is, the specified expression is matched against the entire name string of the table; it does not match substrings that might be present in a table name.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-isolation-mode"></a><a href="#sqlserver-property-snapshot-isolation-mode"><code>snapshot.isolation.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><em>repeatable_read</em></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Mode to control which transaction isolation level is used and how long the connector locks tables that are designated for capture.
The following values are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_uncommitted</code></p>
</li>
<li>
<p><code>read_committed</code></p>
</li>
<li>
<p><code>repeatable_read</code></p>
</li>
<li>
<p><code>snapshot</code></p>
</li>
<li>
<p><code>exclusive</code> (<code>exclusive</code> mode uses repeatable read isolation level, however, it takes the exclusive lock on all tables
to be read).<br></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>snapshot</code>, <code>read_committed</code> and <code>read_uncommitted</code> modes do not prevent other
transactions from updating table rows during initial snapshot.
The <code>exclusive</code> and <code>repeatable_read</code> modes do prevent concurrent updates.<br></p>
</div>
<div class="paragraph">
<p>Mode choice also affects data consistency. Only <code>exclusive</code> and <code>snapshot</code> modes guarantee full consistency, that is, initial
snapshot and streaming logs constitute a linear history.
In case of <code>repeatable_read</code> and <code>read_committed</code> modes, it might happen that, for instance, a record added appears
twice - once in initial snapshot and once in streaming phase. Nonetheless, that consistency level should do for
data mirroring.
For <code>read_uncommitted</code> there are no data consistency guarantees at all (some data might be lost or corrupted).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-event-processing-failure-handling-mode"></a><a href="#sqlserver-property-event-processing-failure-handling-mode"><code>event.processing.failure.handling.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>fail</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how the connector should react to exceptions during processing of events.
<code>fail</code> will propagate the exception (indicating the offset of the problematic event), causing the connector to stop.<br>
<code>warn</code> will cause the problematic event to be skipped and the offset of the problematic event to be logged.<br>
<code>skip</code> will cause the problematic event to be skipped.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-poll-interval-ms"></a><a href="#sqlserver-property-poll-interval-ms"><code>poll.interval.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>500</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the number of milliseconds the connector should wait during each iteration for new change events to appear. Defaults to 500 milliseconds, or 0.5 second.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-max-queue-size"></a><a href="#sqlserver-property-max-queue-size"><code>max.queue.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>8192</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum number of records that the blocking queue can hold.
When Debezium reads events streamed from the database, it places the events in the blocking queue before it writes them to Kafka.
The blocking queue can provide backpressure for reading change events from the database
in cases where the connector ingests messages faster than it can write them to Kafka, or when Kafka becomes unavailable.
Events that are held in the queue are disregarded when the connector periodically records offsets.
Always set the value of <code>max.queue.size</code> to be larger than the value of <a href="#sqlserver-property-max-batch-size"><code>max.batch.size</code></a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-max-queue-size-in-bytes"></a><a href="#sqlserver-property-max-queue-size-in-bytes"><code>max.queue.size.in.bytes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>0</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A long integer value that specifies the maximum volume of the blocking queue in bytes.
By default, volume limits are not specified for the blocking queue.
To specify the number of bytes that the queue can consume, set this property to a positive long value.<br>
If <a href="#sqlserver-property-max-queue-size"><code>max.queue.size</code></a> is also set, writing to the queue is blocked when the size of the queue reaches the limit specified by either property.
For example, if you set <code>max.queue.size=1000</code>, and <code>max.queue.size.in.bytes=5000</code>, writing to the queue is blocked after the queue contains 1000 records, or after the volume of the records in the queue reaches 5000 bytes.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-max-batch-size"></a><a href="#sqlserver-property-max-batch-size"><code>max.batch.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>2048</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-heartbeat-interval-ms"></a><a href="#sqlserver-property-heartbeat-interval-ms"><code>heartbeat.interval.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>0</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls how frequently heartbeat messages are sent.<br>
This property contains an interval in milliseconds that defines how frequently the connector sends messages to a heartbeat topic.
The property can be used to confirm whether the connector is still receiving change events from the database.
You also should leverage heartbeat messages in cases where only records in non-captured tables are changed for a longer period of time.
In such situation the connector would proceed to read the log from the database but never emit any change messages into Kafka,
which in turn means that no offset updates are committed to Kafka.
This may result in more change events to be re-sent after a connector restart.
Set this parameter to <code>0</code> to not send heartbeat messages at all.<br>
Disabled by default.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-heartbeat-action-query"></a><a href="#sqlserver-property-heartbeat-action-query"><code>heartbeat.action.query</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies a query that the connector executes on the source database when the connector sends a heartbeat message.<br></p>
</div>
<div class="paragraph">
<p>+
This is useful for keeping offsets from becoming stale when capturing changes from a low-traffic database. Create a heartbeat table in the low-traffic database, and set this property to a statement that inserts records into that table, for example: <br></p>
</div>
<div class="paragraph">
<p>+
<code>INSERT INTO test_heartbeat_table (text) VALUES ('test_heartbeat')</code><br></p>
</div>
<div class="paragraph">
<p>+
This allows the connector to receive changes from the low-traffic database and acknowledge their LSNs, which prevents offsets from become stale.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-delay-ms"></a><a href="#sqlserver-property-snapshot-delay-ms"><code>snapshot.delay.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An interval in milli-seconds that the connector should wait before taking a snapshot after starting up;<br>
Can be used to avoid snapshot interruptions when starting multiple connectors in a cluster, which may cause re-balancing of connectors.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-streaming-delay-ms"></a><a href="#sqlserver-property-streaming-delay-ms"><code>streaming.delay.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>0</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the time, in milliseconds, that the connector delays the start of the streaming process after it completes a snapshot.
Setting a delay interval helps to prevent the connector from restarting snapshots in the event that a failure occurs immediately after the snapshot completes, but before the streaming process begins.
Set a delay value that is higher than the value of the <a href="https://kafka.apache.org/documentation/#connectconfigs_offset.flush.interval.ms"><code>offset.flush.interval.ms</code></a> property that is set for the Kafka Connect worker.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-fetch-size"></a><a href="#sqlserver-property-snapshot-fetch-size"><code>snapshot.fetch.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>2000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the maximum number of rows that should be read in one go from each table while taking a snapshot.
The connector will read the table contents in multiple batches of this size. Defaults to 2000.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-query-fetch-size"></a><a href="#sqlserver-property-query-fetch-size"><code>query.fetch.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the number of rows that will be fetched for each database round-trip of a given query.
Defaults to the JDBC driver&#8217;s default fetch size.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-lock-timeout-ms"></a><a href="#sqlserver-property-snapshot-lock-timeout-ms"><code>snapshot.lock.timeout.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>10000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An integer value that specifies the maximum amount of time (in milliseconds) to wait to obtain table locks when performing a snapshot. If table locks cannot be acquired in this time interval, the snapshot will fail (also see <a href="#sqlserver-snapshots">snapshots</a>).<br>
When set to <code>0</code> the connector will fail immediately when it cannot obtain the lock. Value <code>-1</code> indicates infinite waiting.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-select-statement-overrides"></a><a href="#sqlserver-property-snapshot-select-statement-overrides"><code>snapshot.select.statement.overrides</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the table rows to include in a snapshot.
Use the property if you want a snapshot to include only a subset of the rows in a table.
This property affects snapshots only.
It does not apply to events that the connector reads from the log.</p>
</div>
<div class="paragraph">
<p>The property contains a comma-separated list of fully-qualified table names in the form <code><em>&lt;schemaName&gt;.&lt;tableName&gt;</em></code>. For example,<br>
<br>
<code>"snapshot.select.statement.overrides": "inventory.products,customers.orders"</code><br>
<br>
For each table in the list, add a further configuration property that specifies the <code>SELECT</code> statement for the connector to run on the table when it takes a snapshot.
The specified <code>SELECT</code> statement determines the subset of table rows to include in the snapshot.
Use the following format to specify the name of this <code>SELECT</code> statement property:<br>
<br>
<code>snapshot.select.statement.overrides.<em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em></code>.
For example,
<code>snapshot.select.statement.overrides.customers.orders</code>.<br>
<br>
Example:</p>
</div>
<div class="paragraph">
<p>From a <code>customers.orders</code> table that includes the soft-delete column, <code>delete_flag</code>, add the following properties if you want a snapshot to include only those records that are not soft-deleted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"snapshot.select.statement.overrides": "customer.orders",
"snapshot.select.statement.overrides.customer.orders": "SELECT * FROM [customers].[orders] WHERE delete_flag = 0 ORDER BY id DESC"</pre>
</div>
</div>
<div class="paragraph">
<p>In the resulting snapshot, the connector includes only the records for which <code>delete_flag = 0</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-source-struct-version"></a><a href="#sqlserver-property-source-struct-version"><code>source.struct.version</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>v2</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Schema version for the <code>source</code> block in CDC events; Debezium 0.10 introduced a few breaking<br>
changes to the structure of the <code>source</code> block in order to unify the exposed structure across
all the connectors.<br>
By setting this option to <code>v1</code> the structure used in earlier versions can be produced.
Note that this setting is not recommended and is planned for removal in a future Debezium version.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-provide-transaction-metadata"></a><a href="#sqlserver-property-provide-transaction-metadata"><code>provide.transaction.metadata</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When set to <code>true</code> Debezium generates events with transaction boundaries and enriches data events envelope with transaction metadata.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-retriable-restart-connector-wait-ms"></a><a href="#sqlserver-property-retriable-restart-connector-wait-ms"><code>retriable.restart.connector.wait.ms</code></a><br></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>10000 (10 seconds)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milli-seconds to wait before restarting a connector after a retriable error occurs.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-skipped-operations"></a><a href="#sqlserver-property-skipped-operations"><code>skipped.operations</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>t</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A comma-separated list of operation types that will be skipped during streaming.
The operations include: <code>c</code> for inserts/create, <code>u</code> for updates, <code>d</code> for deletes, <code>t</code> for truncates, and <code>none</code> to not skip any operations.
By default, truncate operations are skipped (not emitted by this connector).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-data-collection"></a><a href="#sqlserver-property-signal-data-collection"><code>signal.data.collection</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default value</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Fully-qualified name of the data collection that is used to send <a href="../configuration/signalling.html#debezium-signaling-enabling-source-signaling-channel" class="xref page">signals</a> to the connector.<br>
Use the following format to specify the collection name:<br>
<code><em>&lt;databaseName&gt;</em>.<em>&lt;schemaName&gt;</em>.<em>&lt;tableName&gt;</em></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-enabled-channels"></a><a href="#sqlserver-property-signal-enabled-channels"><code>signal.enabled.channels</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>source</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>List of the signaling channel names that are enabled for the connector.
By default, the following channels are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>source</code></p>
</li>
<li>
<p><code>kafka</code></p>
</li>
<li>
<p><code>file</code></p>
</li>
<li>
<p><code>jmx</code>
Optionally, you can also implement a <a href="../configuration/signalling.html#debezium-signaling-enabling-custom-signaling-channel" class="xref page">custom signaling channel</a>.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-notification-enabled-channels"></a><a href="#sqlserver-property-notification-enabled-channels"><code>notification.enabled.channels</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>List of notification channel names that are enabled for the connector.
By default, the following channels are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sink</code></p>
</li>
<li>
<p><code>log</code></p>
</li>
<li>
<p><code>jmx</code>
Optionally, you can also implement a <a href="../configuration/notification.html#debezium-notification-custom-channel" class="xref page">custom notification channel</a>.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-incremental-snapshot-allow-schema-changes"></a><a href="#sqlserver-property-incremental-snapshot-allow-schema-changes"><code>incremental.snapshot.allow.schema.changes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allow schema changes during an incremental snapshot. When enabled the connector will detect schema change during an incremental snapshot and re-select a current chunk to avoid locking DDLs.<br>
<br>
Note that changes to a primary key are not supported and can cause incorrect results if performed during an incremental snapshot. Another limitation is that if a schema change affects only columns' default values, then the change won&#8217;t be detected until the DDL is processed from the transaction log stream. This doesn&#8217;t affect the snapshot events' values, but the schema of snapshot events may have outdated defaults.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-incremental-snapshot-chunk-size"></a><a href="#sqlserver-property-incremental-snapshot-chunk-size"><code>incremental.snapshot.chunk.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1024</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of rows that the connector fetches and reads into memory during an incremental snapshot chunk.
Increasing the chunk size provides greater efficiency, because the snapshot runs fewer snapshot queries of a greater size.
However, larger chunk sizes also require more memory to buffer the snapshot data.
Adjust the chunk size to a value that provides the best performance in your environment.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-incremental-snapshot-watermarking-strategy"></a><a href="#sqlserver-property-incremental-snapshot-watermarking-strategy"><code>incremental.snapshot.watermarking.strategy</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>insert_insert</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the watermarking mechanism that the connector uses during an incremental snapshot to deduplicate events that might be captured by an incremental snapshot and then recaptured after streaming resumes.<br>
You can specify one of the following options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>insert_insert</code></dt>
<dd>
<p>When you send a signal to initiate an incremental snapshot, for every chunk that Debezium reads during the snapshot, it writes an entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, Debezium inserts a second entry that records the signal to close the window.</p>
</dd>
<dt class="hdlist1"><code>insert_delete</code></dt>
<dd>
<p>When you send a signal to initiate an incremental snapshot, for every chunk that Debezium reads, it writes a single entry to the signaling data collection to record the signal to open the snapshot window.
After the snapshot completes, this entry is removed.
No entry is created for the signal to close the snapshot window.
Set this option to prevent rapid growth of the signaling data collection.</p>
</dd>
</dl>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-max-iteration-transactions"></a><a href="#sqlserver-property-max-iteration-transactions"><code>max.iteration.transactions</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>500</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the maximum number of transactions per iteration to be used to reduce the memory footprint when streaming changes from multiple tables in a database.
When set to <code>0</code>, the connector uses the current maximum LSN as the range to fetch changes from.
When set to a value greater than zero, the connector uses the n-th LSN specified by this setting as the range to fetch changes from. Defaults to 500.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-incremental-snapshot-option-recompile"></a><a href="#sqlserver-property-incremental-snapshot-option-recompile"><code>incremental.snapshot.option.recompile</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Uses OPTION(RECOMPILE) query option to all SELECT statements used during an incremental snapshot. This can help to solve parameter sniffing issues that may occur but can cause increased CPU load on the source database, depending on the frequency of query execution.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-naming-strategy"></a><a href="#sqlserver-property-topic-naming-strategy"><code>topic.naming.strategy</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>io.debezium.schema.SchemaTopicNamingStrategy</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc., defaults to <code>SchemaTopicNamingStrategy</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-delimiter"></a><a href="#sqlserver-property-topic-delimiter"><code>topic.delimiter</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>.</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specify the delimiter for topic name, defaults to <code>.</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-cache-size"></a><a href="#sqlserver-property-topic-cache-size"><code>topic.cache.size</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>10000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The size used for holding the topic names in bounded concurrent hash map. This cache will help to determine the topic name corresponding to a given data collection.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-heartbeat-prefix"></a><a href="#sqlserver-property-topic-heartbeat-prefix"><code>topic.heartbeat.prefix</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>__debezium-heartbeat</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls the name of the topic to which the connector sends heartbeat messages. The topic name has this pattern:<br>
<br>
<em>topic.heartbeat.prefix</em>.<em>topic.prefix</em><br>
<br>
For example, if the topic prefix is <code>fulfillment</code>, the default topic name is <code>__debezium-heartbeat.fulfillment</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-topic-transaction"></a><a href="#sqlserver-property-topic-transaction"><code>topic.transaction</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>transaction</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls the name of the topic to which the connector sends transaction metadata messages. The topic name has this pattern:<br>
<br>
<em>topic.prefix</em>.<em>topic.transaction</em><br>
<br>
For example, if the topic prefix is <code>fulfillment</code>, the default topic name is <code>fulfillment.transaction</code>.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="#sqlserver-transaction-metadata">Transaction Metadata</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-snapshot-max-threads"></a><a href="#sqlserver-property-snapshot-max-threads"><code>snapshot.max.threads</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>1</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the number of threads that the connector uses when performing an initial snapshot.
To enable parallel initial snapshots, set the property to a value greater than 1.
In a parallel initial snapshot, the connector processes multiple tables concurrently.
This feature is incubating.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-custom-metric-tags"></a><a href="#sqlserver-property-custom-metric-tags"><code>custom.metric.tags</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>No default</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Defines tags that customize MBean object names by adding metadata that provides contextual information.
Specify a comma-separated list of key-value pairs.
Each key represents a tag for the MBean object name, and the corresponding value represents a value for the key, for example, <br>
<code>k1=v1,k2=v2</code></p>
</div>
<div class="paragraph">
<p>The connector appends the specified tags to the base MBean object name.
Tags can help you to organize and categorize metrics data.
You can define tags to identify particular application instances, environments, regions, versions, and so forth.
For more information, see <a href="#customized-mbean-names">Customized MBean names</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-errors-max-retires"></a><a href="#sqlserver-property-errors-max-retires"><code>errors.max.retries</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>-1</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies how the connector responds after an operation that results in a retriable error, such as a connection error.<br>
Set one of the following options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-1</code></dt>
<dd>
<p>No limit. The connector always restarts automatically, and retries the operation, regardless of the number of previous failures.</p>
</dd>
<dt class="hdlist1"><code>0</code></dt>
<dd>
<p>Disabled. The connector fails immediately, and never retries the operation.
User intervention is required to restart the connector.</p>
</dd>
<dt class="hdlist1"><code>&gt; 0</code></dt>
<dd>
<p>The connector restarts automatically until it reaches the specified maximum number of retries.
After the next failure, the connector stops, and user intervention is required to restart it.</p>
</dd>
</dl>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-data-query-mode"></a><a href="#sqlserver-property-data-query-mode"><code>data.query.mode</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>function</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Controls how the connector queries CDC data. The following modes are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>function</code>: The data is queried by calling <code>cdc.[fn_cdc_get_all_changes_#]</code> function. This is the default mode.</p>
</li>
<li>
<p><code>direct</code>: Makes the connector to query change tables directly. Switching to <code>direct</code> mode and creating an index on <code>(__$start_lsn ASC, __$seqval ASC, __$operation ASC)</code> columns for each change table significantly speeds up querying CDC data.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-query-timeout-ms"></a><a href="#sqlserver-property-database-query-timeout-ms"><code>database.query.timeout.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>600000</code> (10 minutes)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies the time, in milliseconds, that the connector waits for a query to complete.
Set the value to <code>0</code> (zero) to remove the timeout limit.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="debezium-sqlserver-connector-database-history-configuration-properties"><a class="anchor" href="#debezium-sqlserver-connector-database-history-configuration-properties"></a>Debezium SQL Server connector database schema history configuration properties</h4>
<div class="paragraph">
<p>Debezium provides a set of <code>schema.history.internal.*</code> properties that control how the connector interacts with the schema history topic.</p>
</div>
<div class="paragraph">
<p>The following table describes the <code>schema.history.internal</code> properties for configuring the Debezium connector.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. Connector database schema history configuration properties</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 17%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-topic"></a><a href="#sqlserver-property-database-history-kafka-topic"><code>schema.history.internal.kafka.topic</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The full name of the Kafka topic where the connector stores the database schema history.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-bootstrap-servers"></a><a href="#sqlserver-property-database-history-kafka-bootstrap-servers"><code>schema.history.internal.kafka.bootstrap.servers</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving the database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-recovery-poll-interval-ms"></a><a href="#sqlserver-property-database-history-kafka-recovery-poll-interval-ms"><code>schema.history.internal.kafka.recovery.poll.interval.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>100</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An integer value that specifies the maximum number of milliseconds the connector should wait during startup/recovery while polling for persisted data. The default is 100ms.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-query-timeout-ms"></a><a href="#sqlserver-property-database-history-kafka-query-timeout-ms"><code>schema.history.internal.kafka.query.timeout.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>3000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An integer value that specifies the maximum number of milliseconds the connector should wait while fetching cluster information using Kafka admin client.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-create-timeout-ms"></a><a href="#sqlserver-property-database-history-kafka-create-timeout-ms"><code>schema.history.internal.kafka.create.timeout.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>30000</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An integer value that specifies the maximum number of milliseconds the connector should wait while create kafka history topic using Kafka admin client.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-kafka-recovery-attempts"></a><a href="#sqlserver-property-database-history-kafka-recovery-attempts"><code>schema.history.internal.kafka.recovery.attempts</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>100</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum number of times that the connector should try to read persisted history data before the connector recovery fails with an error. The maximum amount of time to wait after receiving no data is <code>recovery.attempts</code> × <code>recovery.poll.interval.ms</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-skip-unparseable-ddl"></a><a href="#sqlserver-property-database-history-skip-unparseable-ddl"><code>schema.history.internal.skip.unparseable.ddl</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A Boolean value that specifies whether the connector should ignore malformed or unknown database statements or stop processing so a human can fix the issue.
The safe default is <code>false</code>.
Skipping should be used only with care as it can lead to data loss or mangling when the binlog is being processed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-store-only-captured-tables-ddl"></a><a href="#sqlserver-property-database-history-store-only-captured-tables-ddl"><code>schema.history.internal.store.only.captured.tables.ddl</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A Boolean value that specifies whether the connector records schema structures from all tables in a schema or database, or only from tables that are designated for capture.<br>
Specify one of the following values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>false</code> (default)</dt>
<dd>
<p>During a database snapshot, the connector records the schema data for all non-system tables in the database, including tables that are not designated for capture.
It&#8217;s best to retain the default setting.
If you later decide to capture changes from tables that you did not originally designate for capture, the connector can easily begin to capture data from those tables, because their schema structure is already stored in the schema history topic.
Debezium requires the schema history of a table so that it can identify the structure that was present at the time that a change event occurred.</p>
</dd>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>During a database snapshot, the connector records the table schemas only for the tables from which Debezium captures change events.
If you change the default value, and you later configure the connector to capture data from other tables in the database, the connector lacks the schema information that it requires to capture change events from the tables.<br></p>
</dd>
</dl>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-database-history-store-only-captured-databases-ddl"></a><a href="#sqlserver-property-database-history-store-only-captured-databases-ddl"><code>schema.history.internal.store.only.captured.databases.ddl</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A Boolean value that specifies whether the connector records schema structures from all logical databases in the database instance.<br>
Specify one of the following values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>The connector records schema structures only for tables in the logical database and schema from which Debezium captures change events.</p>
</dd>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>The connector records schema structures for all logical databases.<br></p>
</dd>
</dl>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="debezium-sqlserver-connector-pass-through-properties"><a class="anchor" href="#debezium-sqlserver-connector-pass-through-properties"></a>Pass-through SQL Server connector configuration properties</h4>
<div class="paragraph">
<p>The connector supports <em>pass-through</em> properties that enable Debezium to specify custom configuration options for fine-tuning the behavior of the Apache Kafka producer and consumer.
For information about the full range of configuration properties for Kafka producers and consumers, see the <a href="https://kafka.apache.org/documentation/#configuration">Kafka documentation</a>.</p>
</div>
<div class="sect4">
<h5 id="debezium-sqlserver-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"><a class="anchor" href="#debezium-sqlserver-pass-through-database-history-properties-for-configuring-producer-and-consumer-clients"></a>Pass-through properties for configuring how producer and consumer clients interact with schema history topics</h5>
<div class="paragraph">
<p>Debezium relies on an Apache Kafka producer to write schema changes to database schema history topics.
Similarly, it relies on a Kafka consumer to read from database schema history topics when a connector starts.
You define the configuration for the Kafka producer and consumer clients by assigning values to a set of pass-through configuration properties that begin with the <code>schema.history.internal.producer.*</code> and <code>schema.history.internal.consumer.*</code> prefixes.
The pass-through producer and consumer database schema history properties control a range of behaviors, such as how these clients secure connections with the Kafka broker, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">schema.history.internal.producer.security.protocol=SSL
schema.history.internal.producer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.producer.ssl.keystore.password=test1234
schema.history.internal.producer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.producer.ssl.truststore.password=test1234
schema.history.internal.producer.ssl.key.password=test1234

schema.history.internal.consumer.security.protocol=SSL
schema.history.internal.consumer.ssl.keystore.location=/var/private/ssl/kafka.server.keystore.jks
schema.history.internal.consumer.ssl.keystore.password=test1234
schema.history.internal.consumer.ssl.truststore.location=/var/private/ssl/kafka.server.truststore.jks
schema.history.internal.consumer.ssl.truststore.password=test1234
schema.history.internal.consumer.ssl.key.password=test1234</code></pre>
</div>
</div>
<div class="paragraph">
<p>Debezium strips the prefix from the property name before it passes the property to the Kafka client.</p>
</div>
<div class="paragraph">
<p>For more information about <a href="https://kafka.apache.org/documentation.html#producerconfigs">Kafka producer configuration properties</a> and <a href="https://kafka.apache.org/documentation.html#consumerconfigs">Kafka consumer configuration properties</a>, see the Apache Kafka documentation .</p>
</div>
</div>
<div class="sect4">
<h5 id="debezium-sqlserver-connector-pass-through-kafka-signals-configuration-properties"><a class="anchor" href="#debezium-sqlserver-connector-pass-through-kafka-signals-configuration-properties"></a>Pass-through properties for configuring how the SQL Server connector interacts with the Kafka signaling topic</h5>
<div class="paragraph">
<p>Debezium provides a set of <code>signal.*</code> properties that control how the connector interacts with the Kafka signals topic.</p>
</div>
<div class="paragraph">
<p>The following table describes the Kafka <code>signal</code> properties.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. Kafka signals configuration properties</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 17%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-kafka-topic"></a><a href="#sqlserver-property-signal-kafka-topic"><code>signal.kafka.topic</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>&lt;topic.prefix&gt;-signal</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the Kafka topic that the connector monitors for ad hoc signals.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If <a href="../configuration/topic-auto-create-config.html#topic-auto-create-config" class="xref page">automatic topic creation</a> is disabled, you must manually create the required signaling topic.
A signaling topic is required to preserve signal ordering.
The signaling topic must have a single partition.</p>
</div>
</td>
</tr>
</table>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-kafka-groupId"></a><a href="#sqlserver-property-signal-kafka-groupId"><code>signal.kafka.groupId</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>kafka-signal</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the group ID that is used by Kafka consumers.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-kafka-bootstrap-servers"></a><a href="#sqlserver-property-signal-kafka-bootstrap-servers"><code>signal.kafka.bootstrap.servers</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A list of the host and port pairs that the connector uses to establish its initial connection to the Kafka cluster.
Each pair references the Kafka cluster that is used by the Debezium Kafka Connect process.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-signal-kafka-poll-timeout-ms"></a><a href="#sqlserver-property-signal-kafka-poll-timeout-ms"><code>signal.kafka.poll.timeout.ms</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>100</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>An integer value that specifies the maximum number of milliseconds that the connector waits when polling signals.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-kafka-consumer-offset-commit-enabled"></a><a href="#sqlserver-kafka-consumer-offset-commit-enabled"><code>kafka.consumer.offset.commit.enabled</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>false</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Specifies whether the Kafka consumer writes an offset commit after it reads a message from the signaling topic.
The value that you assign to this property determines whether the connector can process requests that the signaling topic receives while the connector is offline.
Choose one of the following settings:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>When the connector is unavailable, the Kafka consumer does not commit an offset after it reads a signal received by the signaling topic.
As a result, if the connector is offline for any interval, it cannot process requests that the signaling topic receives during the downtime.
After the connector restarts, it always reads from the last position in the Kafka signaling topic, processing only signals that it receives after the restart.
Signals received while the connector is offline are ignored, and are effectively lost.</p>
</dd>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>When a user submits a request to the signaling topic, after the Kafka consumer reads the signal message it commits a topic offset, even if the connector is offline.
Choose this option to provide Debezium with information about the last signal message that the consumer read, helping to ensure At-Least-Once delivery.
After a connector restarts, it resumes processing from the last recorded offset, responding to signals that users submitted while the connector is offline.</p>
</dd>
</dl>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="debezium-sqlserver-connector-pass-through-signals-kafka-consumer-client-configuration-properties"><a class="anchor" href="#debezium-sqlserver-connector-pass-through-signals-kafka-consumer-client-configuration-properties"></a>Pass-through properties for configuring the Kafka consumer client for the signaling channel</h5>
<div class="paragraph">
<p>The Debezium connector provides for pass-through configuration of the signals Kafka consumer.
Pass-through signals properties begin with the prefix <code>signals.consumer.*</code>.
For example, the connector passes properties such as <code>signal.consumer.security.protocol=SSL</code> to the Kafka consumer.</p>
</div>
<div class="paragraph">
<p>Debezium strips the prefixes from the properties before it passes the properties to the Kafka signals consumer.</p>
</div>
</div>
<div class="sect4">
<h5 id="debezium-sqlserver-connector-pass-through-kafka-sink-notification-configuration-properties"><a class="anchor" href="#debezium-sqlserver-connector-pass-through-kafka-sink-notification-configuration-properties"></a>Pass-through properties for configuring the SQL Server connector sink notification channel</h5>
<div class="paragraph">
<p>The following table describes properties that you can use to configure the Debezium sink <code>notification</code> channel.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. Sink notification configuration properties</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 17%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="sqlserver-property-notification-sink-topic-name"></a><a href="#sqlserver-property-notification-sink-topic-name"><code>notification.sink.topic.name</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>No default</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The name of the topic that receives notifications from Debezium.
This property is required when you configure the <a href="#sqlserver-property-notification-enabled-channels"><code>notification.enabled.channels</code></a> property to include <code>sink</code> as one of the enabled notification channels.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="debezium-sqlserver-connector-pass-through-database-driver-configuration-properties"><a class="anchor" href="#debezium-sqlserver-connector-pass-through-database-driver-configuration-properties"></a>Debezium connector pass-through database driver configuration properties</h5>
<div class="paragraph">
<p>The Debezium connector provides for pass-through configuration of the database driver.
Pass-through database properties begin with the prefix <code>driver.*</code>.
For example, the connector passes properties such as <code>driver.foobar=false</code> to the JDBC URL.</p>
</div>
<div class="paragraph">
<p>Debezium strips the prefixes from the properties before it passes the properties to the database driver.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sqlserver-schema-evolution"><a class="anchor" href="#sqlserver-schema-evolution"></a>Database schema evolution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When change data capture is enabled for a SQL Server table, as changes occur in the table, event records are persisted to a capture table on the server.
If you introduce a change in the structure of the source table change, for example, by adding a new column, that change is not dynamically reflected in the change table.
For as long as the capture table continues to use the outdated schema, the Debezium connector is unable to emit data change events for the table correctly.
You must intervene to refresh the capture table to enable the connector to resume processing change events.</p>
</div>
<div class="paragraph">
<p>Because of the way that CDC is implemented in SQL Server, you cannot use Debezium to update capture tables.
To refresh capture tables, one must be a SQL Server database operator with elevated privileges.
As a Debezium user, you must coordinate tasks with the SQL Server database operator to complete the schema refresh and restore streaming to Kafka topics.</p>
</div>
<div class="paragraph">
<p>You can use one of the following methods to update capture tables after a schema change:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#offline-schema-updates">Offline schema updates</a> require you to stop the Debezium connector before you can update capture tables.</p>
</li>
<li>
<p><a href="#online-schema-updates">Online schema updates</a> can update capture tables while the Debezium connector is running.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are advantages and disadvantages to using each type of procedure.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Whether you use the online or offline update method, you must complete the entire schema update process before you apply subsequent schema updates on the same source table.
The best practice is to execute all DDLs in a single batch so the procedure can be run only once.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some schema changes are not supported on source tables that have CDC enabled.
For example, if CDC is enabled on a table, SQL Server does not allow you to change the schema of the table if you renamed one of its columns or changed the column type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>After you change a column in a source table from <code>NULL</code> to <code>NOT NULL</code> or vice versa, the SQL Server connector cannot correctly capture the changed information until after you create a new capture instance.
If you do not create a new capture table after a change to the column designation, change event records that the connector emits do not correctly indicate whether the column is optional.
That is, columns that were previously defined as optional (or <code>NULL</code>) continue to be, despite now being defined as <code>NOT NULL</code>.
Similarly, columns that had been defined as required (<code>NOT NULL</code>), retain that designation, although they are now defined as <code>NULL</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>After you rename a table using <code>sp_rename</code> function, it will continue to emit changes under the old source table name until the connector is restarted.
Upon restart of the connector, it will emit changes under the new source table name.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="offline-schema-updates"><a class="anchor" href="#offline-schema-updates"></a>Offline schema updates</h3>
<div class="paragraph">
<p>Offline schema updates provide the safest method for updating capture tables.
However, offline updates might not be feasible for use with applications that require high-availability.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>An update was committed to the schema of a SQL Server table that has CDC enabled.</p>
</li>
<li>
<p>You are a SQL Server database operator with elevated privileges.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Suspend the application that updates the database.</p>
</li>
<li>
<p>Wait for the Debezium connector to stream all unstreamed change event records.</p>
</li>
<li>
<p>Stop the Debezium connector.</p>
</li>
<li>
<p>Apply all changes to the source table schema.</p>
</li>
<li>
<p>Create a new capture table for the update source table using <code>sys.sp_cdc_enable_table</code> procedure with a unique value for parameter <code>@capture_instance</code>.</p>
</li>
<li>
<p>Resume the application that you suspended in Step 1.</p>
</li>
<li>
<p>Start the Debezium connector.</p>
</li>
<li>
<p>After the Debezium connector starts streaming from the new capture table, drop the old capture table by running the stored procedure <code>sys.sp_cdc_disable_table</code> with the parameter <code>@capture_instance</code> set to the old capture instance name.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="online-schema-updates"><a class="anchor" href="#online-schema-updates"></a>Online schema updates</h3>
<div class="paragraph">
<p>The procedure for completing an online schema updates is simpler than the procedure for running an offline schema update,
and you can complete it without requiring any downtime in application and data processing.
However, with online schema updates, a potential processing gap can occur after you update the schema in the source database,
but before you create the new capture instance.
During that interval, change events continue to be captured by the old instance of the change table,
and the change data that is saved to the old table retains the structure of the earlier schema.
So, for example, if you added a new column to a source table, change events that are produced before the new capture table is ready, do not contain a field for the new column.
If your application does not tolerate such a transition period, it is best to use the offline schema update procedure.</p>
</div>
<div class="ulist">
<div class="title">Prerequisites</div>
<ul>
<li>
<p>An update was committed to the schema of a SQL Server table that has CDC enabled.</p>
</li>
<li>
<p>You are a SQL Server database operator with elevated privileges.</p>
</li>
</ul>
</div>
<div class="olist arabic">
<div class="title">Procedure</div>
<ol class="arabic">
<li>
<p>Apply all changes to the source table schema.</p>
</li>
<li>
<p>Create a new capture table for the update source table by running the <code>sys.sp_cdc_enable_table</code> stored procedure with a unique value for the parameter <code>@capture_instance</code>.</p>
</li>
<li>
<p>When Debezium starts streaming from the new capture table, you can drop the old capture table by running the <code>sys.sp_cdc_disable_table</code> stored procedure with the parameter <code>@capture_instance</code> set to the old capture instance name.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">Example: Running an online schema update after a database schema change</div>
<p>Let&#8217;s deploy the SQL Server based <a href="https://github.com/debezium/debezium-examples/tree/main/tutorial#using-sql-server">Debezium tutorial</a> to demonstrate the online schema update.</p>
</div>
<div class="paragraph">
<p>In the following example, a column <code>phone_number</code> is added to the <code>customers</code> table.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Type the following command to start the database shell:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>docker-compose -f docker-compose-sqlserver.yaml exec sqlserver bash -c '/opt/mssql-tools/bin/sqlcmd -U sa -P $SA_PASSWORD -d testDB'</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Modify the schema of the <code>customers</code> source table by running the following query to add the <code>phone_number</code> field:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">ALTER TABLE customers ADD phone_number VARCHAR(32);</code></pre>
</div>
</div>
</li>
<li>
<p>Create the new capture instance by running the <code>sys.sp_cdc_enable_table</code> stored procedure.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">EXEC sys.sp_cdc_enable_table @source_schema = 'dbo', @source_name = 'customers', @role_name = NULL, @supports_net_changes = 0, @capture_instance = 'dbo_customers_v2';
GO</code></pre>
</div>
</div>
</li>
<li>
<p>Insert new data into the <code>customers</code> table by running the following query:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">INSERT INTO customers(first_name,last_name,email,phone_number) VALUES ('John','Doe','john.doe@example.com', '+1-555-123456');
GO</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Kafka Connect log reports on configuration updates through entries similar to the following message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">connect_1    | 2019-01-17 10:11:14,924 INFO   ||  Multiple capture instances present for the same table: Capture instance "dbo_customers" [sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_CT, startLsn=00000024:00000d98:0036, changeTableObjectId=1525580473, stopLsn=00000025:00000ef8:0048] and Capture instance "dbo_customers_v2" [sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]
connect_1    | 2019-01-17 10:11:14,924 INFO   ||  Schema will be changed for ChangeTable [captureInstance=dbo_customers_v2, sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]
...
connect_1    | 2019-01-17 10:11:33,719 INFO   ||  Migrating schema to ChangeTable [captureInstance=dbo_customers_v2, sourceTableId=testDB.dbo.customers, changeTableId=testDB.cdc.dbo_customers_v2_CT, startLsn=00000025:00000ef8:0048, changeTableObjectId=1749581271, stopLsn=NULL]   [io.debezium.connector.sqlserver.SqlServerStreamingChangeEventSource]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eventually, the <code>phone_number</code> field is added to the schema and its value appears in messages written to the Kafka topic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">...
     {
        "type": "string",
        "optional": true,
        "field": "phone_number"
     }
...
    "after": {
      "id": 1005,
      "first_name": "John",
      "last_name": "Doe",
      "email": "john.doe@example.com",
      "phone_number": "+1-555-123456"
    },</code></pre>
</div>
</div>
</li>
<li>
<p>Drop the old capture instance by running the <code>sys.sp_cdc_disable_table</code> stored procedure.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">EXEC sys.sp_cdc_disable_table @source_schema = 'dbo', @source_name = 'dbo_customers', @capture_instance = 'dbo_customers';
GO</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sqlserver-monitoring"><a class="anchor" href="#sqlserver-monitoring"></a>Monitoring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Debezium SQL Server connector provides three types of metrics that are in addition to the built-in support for JMX metrics that Zookeeper, Kafka, and Kafka Connect provide.
The connector provides the following metrics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sqlserver-snapshot-metrics">Snapshot metrics</a> for monitoring the connector when performing snapshots.</p>
</li>
<li>
<p><a href="#sqlserver-streaming-metrics">Streaming metrics</a> for monitoring the connector when reading CDC table data.</p>
</li>
<li>
<p><a href="#sqlserver-schema-history-metrics">Schema history metrics</a> for monitoring the status of the connector&#8217;s schema history.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For information about how to expose the preceding metrics through JMX, see the <a href="../operations/monitoring.html#monitoring-debezium" class="xref page">Debezium monitoring documentation</a>.</p>
</div>
<div class="sect2">
<h3 id="customized-mbean-names"><a class="anchor" href="#customized-mbean-names"></a>Customized MBean names</h3>
<div class="paragraph">
<p>Debezium connectors expose metrics via the MBean name for the connector.
These metrics, which are specific to each connector instance, provide data about the behavior of the connector&#8217;s snapshot, streaming, and schema history processes.</p>
</div>
<div class="paragraph">
<p>By default, when you deploy a correctly configured connector, Debezium generates a unique MBean name for each of the different connector metrics.
To view the metrics for a connector process, you configure your observability stack to monitor its MBean.
But these default MBean names depend on the connector configuration; configuration changes can result in changes to the MBean names.
A change to the MBean name breaks the linkage between the connector instance and the MBean, disrupting monitoring activity.
In this scenario, you must reconfigure the observability stack to use the new MBean name if you want to resume monitoring.</p>
</div>
<div class="paragraph">
<p>To prevent monitoring disruptions that result from MBean name changes, you can configure custom metrics tags.
You configure custom metrics by adding the <code>custom.metric.tags</code> property to the connector configuration.
The property accepts key-value pairs in which each key represents a tag for the MBean object name, and the corresponding value represents the value of that tag.
For example: <code>k1=v1,k2=v2</code>.
Debezium appends the specified tags to the MBean name of the connector.</p>
</div>
<div class="paragraph">
<p>After you configure the <code>custom.metric.tags</code> property for a connector, you can configure the observability stack to retrieve metrics associated with the specified tags.
The observability stack then uses the specified tags, rather than the mutable MBean names to uniquely identify connectors.
Later, if Debezium redefines how it constructs MBean names, or if the <code>topic.prefix</code> in the connector configuration changes, metrics collection is uninterrupted,
because the metrics scrape task uses the specified tag patterns to identify the connector.</p>
</div>
<div class="paragraph">
<p>A further benefit of using custom tags, is that you can use tags that reflect the architecture of your data pipeline, so that metrics are organized in a way that suits you operational needs.
For example, you might specify tags with values that declare the type of connector activity, the application context, or the data source, for example, <code>db1-streaming-for-application-abc</code>.
If you specify multiple key-value pairs, all of the specified pairs are appended to the connector&#8217;s MBean name.</p>
</div>
<div class="paragraph">
<p>The following example illustrates how tags modify the default MBean name.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. How custom tags modify the connector MBean name</div>
<div class="content">
<div class="paragraph">
<p>By default, the SQL Server connector uses the following MBean name for streaming metrics:
<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">debezium.sqlserver:type=connector-metrics,context=streaming,server=<em>&lt;topic.prefix&gt;</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you set the value of <code>custom.metric.tags</code> to <code>database=salesdb-streaming,table=inventory</code>, Debezium generates the following custom MBean name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">debezium.sqlserver:type=connector-metrics,context=streaming,server=<em>&lt;topic.prefix&gt;</em>,database=salesdb-streaming,table=inventory</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sqlserver-snapshot-metrics"><a class="anchor" href="#sqlserver-snapshot-metrics"></a>Snapshot metrics</h3>
<div class="paragraph">
<p>The <strong>MBean</strong> is <code>debezium.sql_server:type=connector-metrics,server=<em>&lt;topic.prefix&gt;</em>,task=<em>&lt;task.id&gt;</em>,context=snapshot</code>.</p>
</div>
<div class="paragraph">
<p>Snapshot metrics are not exposed unless a snapshot operation is active, or if a snapshot has occurred since the last connector start.</p>
</div>
<div class="paragraph">
<p>The following table lists the snapshot metrics that are available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attributes</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-lastevent_sqlserver"></a><a href="#connectors-snaps-metric-lastevent_sqlserver"><code>LastEvent</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The last snapshot event that the connector has read.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-millisecondssincelastevent_sqlserver"></a><a href="#connectors-snaps-metric-millisecondssincelastevent_sqlserver"><code>MilliSecondsSinceLastEvent</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milliseconds since the connector has read and processed the most recent event.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-totalnumberofeventsseen_sqlserver"></a><a href="#connectors-snaps-metric-totalnumberofeventsseen_sqlserver"><code>TotalNumberOfEventsSeen</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of events that this connector has seen since last started or reset.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-numberofeventsfiltered_sqlserver"></a><a href="#connectors-snaps-metric-numberofeventsfiltered_sqlserver"><code>NumberOfEventsFiltered</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of events that have been filtered by include/exclude list filtering rules configured on the connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-capturedtables_sqlserver"></a><a href="#connectors-snaps-metric-capturedtables_sqlserver"><code>CapturedTables</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string[]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The list of tables that are captured by the connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-queuetotalcapacity_sqlserver"></a><a href="#connectors-snaps-metric-queuetotalcapacity_sqlserver"><code>QueueTotalCapacity</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The length the queue used to pass events between the snapshotter and the main Kafka Connect loop.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-queueremainingcapacity_sqlserver"></a><a href="#connectors-snaps-metric-queueremainingcapacity_sqlserver"><code>QueueRemainingCapacity</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The free capacity of the queue used to pass events between the snapshotter and the main Kafka Connect loop.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-totaltablecount_sqlserver"></a><a href="#connectors-snaps-metric-totaltablecount_sqlserver"><code>TotalTableCount</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of tables that are being included in the snapshot.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-remainingtablecount_sqlserver"></a><a href="#connectors-snaps-metric-remainingtablecount_sqlserver"><code>RemainingTableCount</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of tables that the snapshot has yet to copy.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotrunning_sqlserver"></a><a href="#connectors-snaps-metric-snapshotrunning_sqlserver"><code>SnapshotRunning</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether the snapshot was started.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotpaused_sqlserver"></a><a href="#connectors-snaps-metric-snapshotpaused_sqlserver"><code>SnapshotPaused</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether the snapshot was paused.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotaborted_sqlserver"></a><a href="#connectors-snaps-metric-snapshotaborted_sqlserver"><code>SnapshotAborted</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether the snapshot was aborted.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotcompleted_sqlserver"></a><a href="#connectors-snaps-metric-snapshotcompleted_sqlserver"><code>SnapshotCompleted</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Whether the snapshot completed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotdurationinseconds_sqlserver"></a><a href="#connectors-snaps-metric-snapshotdurationinseconds_sqlserver"><code>SnapshotDurationInSeconds</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of seconds that the snapshot has taken so far, even if not complete. Includes also time when snapshot was paused.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-snapshotpauseddurationinseconds_sqlserver"></a><a href="#connectors-snaps-metric-snapshotpauseddurationinseconds_sqlserver"><code>SnapshotPausedDurationInSeconds</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of seconds that the snapshot was paused. If the snapshot was paused several times, the paused time adds up.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-rowsscanned_sqlserver"></a><a href="#connectors-snaps-metric-rowsscanned_sqlserver"><code>RowsScanned</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Map&lt;String, Long&gt;</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Map containing the number of rows scanned for each table in the snapshot.
Tables are incrementally added to the Map during processing.
Updates every 10,000 rows scanned and upon completing a table.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-maxqueuesizeinbytes_sqlserver"></a><a href="#connectors-snaps-metric-maxqueuesizeinbytes_sqlserver"><code>MaxQueueSizeInBytes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum buffer of the queue in bytes. This metric is available if <a href="#sqlserver-property-max-queue-size-in-bytes"><code>max.queue.size.in.bytes</code></a> is set to a positive long value.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-snaps-metric-currentqueuesizeinbytes_sqlserver"></a><a href="#connectors-snaps-metric-currentqueuesizeinbytes_sqlserver"><code>CurrentQueueSizeInBytes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The current volume, in bytes, of records in the queue.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The connector also provides the following additional snapshot metrics when an incremental snapshot is executed:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attributes</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-insnap-metric-chunkid_sqlserver"></a><a href="#connectors-insnap-metric-chunkid_sqlserver"><code>ChunkId</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The identifier of the current snapshot chunk.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-insnap-metric-chunkfrom_sqlserver"></a><a href="#connectors-insnap-metric-chunkfrom_sqlserver"><code>ChunkFrom</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The lower bound of the primary key set defining the current chunk.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-insnap-metric-chunkto_sqlserver"></a><a href="#connectors-insnap-metric-chunkto_sqlserver"><code>ChunkTo</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The upper bound of the primary key set defining the current chunk.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-insnap-metric-tablefrom_sqlserver"></a><a href="#connectors-insnap-metric-tablefrom_sqlserver"><code>TableFrom</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The lower bound of the primary key set of the currently snapshotted table.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-insnap-metric-tableto_sqlserver"></a><a href="#connectors-insnap-metric-tableto_sqlserver"><code>TableTo</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The upper bound of the primary key set of the currently snapshotted table.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="sqlserver-streaming-metrics"><a class="anchor" href="#sqlserver-streaming-metrics"></a>Streaming metrics</h3>
<div class="paragraph">
<p>The <strong>MBean</strong> is <code>debezium.sql_server:type=connector-metrics,server=<em>&lt;topic.prefix&gt;</em>,task=<em>&lt;task.id&gt;</em>,context=streaming</code>.</p>
</div>
<div class="paragraph">
<p>The following table lists the streaming metrics that are available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attributes</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-lastevent_sqlserver"></a><a href="#connectors-strm-metric-lastevent_sqlserver"><code>LastEvent</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The last streaming event that the connector has read.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-millisecondssincelastevent_sqlserver"></a><a href="#connectors-strm-metric-millisecondssincelastevent_sqlserver"><code>MilliSecondsSinceLastEvent</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milliseconds since the connector has read and processed the most recent event.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-totalnumberofeventsseen_sqlserver"></a><a href="#connectors-strm-metric-totalnumberofeventsseen_sqlserver"><code>TotalNumberOfEventsSeen</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of data change events reported by the source database since the last connector start, or since a metrics reset.
Represents the data change workload for Debezium to process.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-totalnumberofcreateeventsseen_sqlserver"></a><a href="#connectors-strm-metric-totalnumberofcreateeventsseen_sqlserver"><code>TotalNumberOfCreateEventsSeen</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of create events processed by the connector since its last start or metrics reset.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-totalnumberofupdateeventsseen_sqlserver"></a><a href="#connectors-strm-metric-totalnumberofupdateeventsseen_sqlserver"><code>TotalNumberOfUpdateEventsSeen</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of update events processed by the connector since its last start or metrics reset.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-totalnumberofdeleteeventsseen_sqlserver"></a><a href="#connectors-strm-metric-totalnumberofdeleteeventsseen_sqlserver"><code>TotalNumberOfDeleteEventsSeen</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The total number of delete events processed by the connector since its last start or metrics reset.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-numberofeventsfiltered_sqlserver"></a><a href="#connectors-strm-metric-numberofeventsfiltered_sqlserver"><code>NumberOfEventsFiltered</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of events that have been filtered by include/exclude list filtering rules configured on the connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-capturedtables_sqlserver"></a><a href="#connectors-strm-metric-capturedtables_sqlserver"><code>CapturedTables</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string[]</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The list of tables that are captured by the connector.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-queuetotalcapacity_sqlserver"></a><a href="#connectors-strm-metric-queuetotalcapacity_sqlserver"><code>QueueTotalCapacity</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The length the queue used to pass events between the streamer and the main Kafka Connect loop.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-queueremainingcapacity_sqlserver"></a><a href="#connectors-strm-metric-queueremainingcapacity_sqlserver"><code>QueueRemainingCapacity</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>int</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The free capacity of the queue used to pass events between the streamer and the main Kafka Connect loop.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-connected_sqlserver"></a><a href="#connectors-strm-metric-connected_sqlserver"><code>Connected</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boolean</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Flag that denotes whether the connector is currently connected to the database server.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-millisecondsbehindsource_sqlserver"></a><a href="#connectors-strm-metric-millisecondsbehindsource_sqlserver"><code>MilliSecondsBehindSource</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milliseconds between the last change event&#8217;s timestamp and the connector processing it.
The values will incorporate any differences between the clocks on the machines where the database server and the connector are running.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-numberofcommittedtransactions_sqlserver"></a><a href="#connectors-strm-metric-numberofcommittedtransactions_sqlserver"><code>NumberOfCommittedTransactions</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of processed transactions that were committed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-sourceeventposition_sqlserver"></a><a href="#connectors-strm-metric-sourceeventposition_sqlserver"><code>SourceEventPosition</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>Map&lt;String, String&gt;</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The coordinates of the last received event.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-lasttransactionid_sqlserver"></a><a href="#connectors-strm-metric-lasttransactionid_sqlserver"><code>LastTransactionId</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Transaction identifier of the last processed transaction.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-maxqueuesizeinbytes_sqlserver"></a><a href="#connectors-strm-metric-maxqueuesizeinbytes_sqlserver"><code>MaxQueueSizeInBytes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The maximum buffer of the queue in bytes. This metric is available if <a href="#sqlserver-property-max-queue-size-in-bytes"><code>max.queue.size.in.bytes</code></a> is set to a positive long value.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-strm-metric-currentqueuesizeinbytes_sqlserver"></a><a href="#connectors-strm-metric-currentqueuesizeinbytes_sqlserver"><code>CurrentQueueSizeInBytes</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The current volume, in bytes, of records in the queue.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="sqlserver-schema-history-metrics"><a class="anchor" href="#sqlserver-schema-history-metrics"></a>Schema history metrics</h3>
<div class="paragraph">
<p>The <strong>MBean</strong> is <code>debezium.sql_server:type=connector-metrics,context=schema-history,server=<em>&lt;topic.prefix&gt;</em></code>.</p>
</div>
<div class="paragraph">
<p>The following table lists the schema history metrics that are available.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45%;">
<col style="width: 25%;">
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attributes</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-status_sqlserver"></a><a href="#connectors-shist-metric-status_sqlserver"><code>Status</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>One of <code>STOPPED</code>, <code>RECOVERING</code> (recovering history from the storage), <code>RUNNING</code> describing the state of the database schema history.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-recoverystarttime_sqlserver"></a><a href="#connectors-shist-metric-recoverystarttime_sqlserver"><code>RecoveryStartTime</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The time in epoch seconds at what recovery has started.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-changesrecovered_sqlserver"></a><a href="#connectors-shist-metric-changesrecovered_sqlserver"><code>ChangesRecovered</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of changes that were read during recovery phase.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-changesapplied_sqlserver"></a><a href="#connectors-shist-metric-changesapplied_sqlserver"><code>ChangesApplied</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>the total number of schema changes applied during recovery and runtime.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-millisecondssincelastrecoveredchange_sqlserver"></a><a href="#connectors-shist-metric-millisecondssincelastrecoveredchange_sqlserver"><code>MilliSecondsSinceLast&#8203;RecoveredChange</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milliseconds that elapsed since the last change was recovered from the history store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-millisecondssincelastappliedchange_sqlserver"></a><a href="#connectors-shist-metric-millisecondssincelastappliedchange_sqlserver"><code>MilliSecondsSinceLast&#8203;AppliedChange</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>long</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The number of milliseconds that elapsed since the last change was applied.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-lastrecoveredchange_sqlserver"></a><a href="#connectors-shist-metric-lastrecoveredchange_sqlserver"><code>LastRecoveredChange</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The string representation of the last change recovered from the history store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a id="connectors-shist-metric-lastappliedchange_sqlserver"></a><a href="#connectors-shist-metric-lastappliedchange_sqlserver"><code>LastAppliedChange</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>string</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The string representation of the last applied change.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</article>
</div>
<div class="article-cell2">
</div>
</div>

<div id="toc-rightbar"></div>    <footer class="footer">
        <div class="wrapper">
            <div class="copyright">Copyright &copy; 2024 Debezium Community (Rev: <span class="truncated"><a href="https://github.com/debezium/debezium/commit/f6d18786398e48398a01dbceac87be1dc8bb8e0a">f6d18786</a></span>)
            
        </div>
    </footer>
</main></div>
<script>
    /* Make sure TOC carets are expanded if sub-elements exist */
    $("#toc").each(function(i,v) {
      $(this).closest('article').addClass('with-toc');
    });

    $("#toc ul.sectlevel1 > li").each(function(i,v) {
      $(this).has("ul").addClass("expanded");
    });

    $(function() {
        /* Expands all the documentation submenus */
        $(".nav-list > .nav-item:not(.is-active) .nav-item-toggle").click();
    });

    /**
     * This checks if a "#toc" element exists in the DOM and if so:
     *
     *  1. Appends a cloned copy of the #toc node to the #toc-rightbar div.
     *  2. Forces the #toc-rightbar div to be visible.
     *  3. Adds the .toc-right class to the #article-wrapper div to restrict the article's overall width.
     */
    var $toc = $("#toc");
    if ( $toc.length ) {
        $("#toc-rightbar").append($toc.clone());
        $("body .main").addClass("with-toc");
    }

    /**
     * In order to make CSS changes that are backward compatible with old adoc files, this applies a version
     * style to the body tag so we can use it to differentiate between CSS styles per version if needed,
     * such as tfoot rows.
     */
    var $version = $("body .nav-container").data("version");
    var $versionClass = "version-" + $version;
    $versionClass = $versionClass.replace('.','-');
    $("body").addClass($versionClass);

    /** A CSS trick to wrap long-width tables in a div that can be scrolled on smaller screens */
    $("table.tableblock").wrap("<div class='table-scroll-wrapper'></div>");

    $(function() {
        /* apply floating scrollbar to the scroll-wrapper */
        $(".table-scroll-wrapper").floatingScrollbar();
    });

</script>
<script src="../../../debezium-antora/js/site.js"></script>
<script async src="../../../debezium-antora/js/vendor/highlight.js"></script>

<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-10656779-1");
    pageTracker._trackPageview();
  } catch(err) {}
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-76464546-1', 'auto');
  ga('send', 'pageview');
  ga('set', 'anonymizeIp', true);
  ga('require', 'linkid', 'linkid.js');
</script>
</body>
</html>