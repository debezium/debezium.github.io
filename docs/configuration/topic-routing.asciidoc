= Topic Routing
:awestruct-layout: doc
:linkattrs:
:icons: font
:source-highlighter: highlight.js

Debezium enables you to re-route the emitted change before the message reaches the converter using a 
single message transformation, or https://kafka.apache.org/documentation/#connect_transforms[SMT]. 
The SMT provided by Debezium enables you to rewrite the topic and the key according to a regular expression 
and a replacement pattern, configurable per instance of Debezium.

The implementation does not care about the sanity of the change, this is in the responsibility of the user.

== Use-Cases

=== Logical Tables

A logical table consists of one or more physical tables with the same table structure. A common use case is sharding, where 
for example two physical tables `db_shard1.my_table` and `db_shard2.my_table` together form one logical table.

Typically the physical tables share the same schema.

Normally, Debezium connectors send each change event to a topic that is named by the database and table. 
But since the sharded tables have the same schema, we'd instead like to re-route each change event to a topic 
named by the _logical_ table name. This way, all changes events for any of the shards all go to the same topic.

What happens if each physical table has a primary key that is only unique within that table? In this case, a 
row in shard 1 can have the same primary key as a row in shard 2. Since Debezium events are keyed by the columns 
that make up the primary key, the events for that row in shard 1 would have the same key as the row in shard 2, 
even though globally they are different rows. So, in addition to changing the topic name, we may also want to _modify 
the event key_ to add a field that makes the key globally unique.

This SMT lets you specify how you want to choose the new topic name and then specify how to modify the change event key 
to ensure it is globally unique.

== Topic Names

Below is an example for a configuration which replaces a part of the table in the topic with another string, allowing
two tables to emit changes to the same topic, keeping their different key namings.

[source]
---
transforms=Reroute
transforms.Reroute.type=io.debezium.transforms.ByLogicalTableRouter
transforms.Reroute.topic.regex=(.*)__bar$
transforms.Reroute.topic.replacement=$1
---

The configuration above will match a topic named `db1.foo__bar` and replace it with `db1.foo`, but keep the key's name
`db1.foo__bar.Key`. If you intend to change also the key's name, please follow the instructions in (key-fields)[Key Fields].

== Key Fields

Using only the topic replacement does not touch the key's field. In order to make it completely transparent to the
consumer, whether the event came from one or another table, a key field change is also required. 

The SMT allows you to define a regular expression that will be applied to the original topic name to capture one or 
more groups of characters, and then an expression that defines the value for the new field in terms of those captured 
groups. For example:

[source]
---
transforms=Reroute
transforms.Reroute.type=io.debezium.transforms.ByLogicalTableRouter
transforms.Reroute.topic.regex=(.*)__bar$
transforms.Reroute.topic.replacement=$1
transforms.Reroute.key.field.regex=(.*)__bar.Key$
transforms.Reroute.key.field.replacement=$1
transforms.Reroute.key.field.name=source_table__
---

We can pick any name for the additional key field, but this example configuration chooses `source_table__` as the _name_ 
of the new field in the change event's key structure. (Obviously you'll want to choose a field name that doesn't clash 
with existing primary key fields.) If no name for the additional key field is specified, it will be named `source_table__PhysicalTableIdentifier.`
We'd like to have the _value_ of this new key field to contain the name of the source table where the event originated, 
so we use the `topic.regex` property to define a regular expression that captures the source table name from the 
original topic, and the `key.field.replacement` property specifies how the new field's value should be computed from 
the captured groups, which in our example is the first capture group that contains the source table name.
 